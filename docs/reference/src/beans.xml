<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="beans">
    <title>The IoC container</title>
    <section id="beans-introduction">
        <title>Introduction</title>
        <para>This chapter is devoted to covering (in detail) the Spring Framework's
        implementation of the Inversion of Control (IoC)
		<footnote><para>See the section entitled <xref linkend="background-ioc" /></para></footnote>
		principle. IoC underpins a lot of the surrounding functionality that is provided by
		the Spring Framework as a whole, and so a thorough treatment of this rich, yet
		conceptually very simple, technology is in order.</para>
        <sidebar>
			<title>Which interface?</title>
            <para>Users are sometimes unsure whether a <interfacename>BeanFactory</interfacename>
            or an <interfacename>ApplicationContext</interfacename> is best suited for use
            in a particular situation. Normally when building most applications in a
            J2EE-environment, <emphasis>the best option is to use the</emphasis>
            <interfacename>ApplicationContext</interfacename>, since it offers
            all the features of the <interfacename>BeanFactory</interfacename>, while also
            allowing a more declarative approach to the use of some functionality, which is
            generally desirable.</para>
        </sidebar>
		<para>The <literal>org.springframework.beans</literal> and
        <literal>org.springframework.context</literal> packages provide the basis
        for the Spring Framework's IoC container. The
        <interfacename><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</ulink></interfacename>
		interface provides an advanced configuration mechanism capable of managing
		objects of any nature. The
        <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink></literal>
        interface builds on top of the <interfacename>BeanFactory</interfacename>
        (it is a sub-interface) and adds other functionality such as easier integration
        with Spring's AOP features, message resource handling (for use in
        internationalization), event propagation, and application-layer specific contexts
        such as the <interfacename>WebApplicationContext</interfacename> for use in web
        applications.</para>
		<para>In short, the <interfacename>BeanFactory</interfacename> provides the
		configuration framework and basic functionality, while the
		<interfacename>ApplicationContext</interfacename> adds more enterprise-centric
		functionality to it. The <interfacename>ApplicationContext</interfacename> is a
		complete superset of the <interfacename>BeanFactory</interfacename>, and any
		description of <interfacename>BeanFactory</interfacename> capabilities and
		behavior is to be considered to apply to the
		<interfacename>ApplicationContext</interfacename> as well.</para>
		<para>This chapter is divided into two parts, with the
		<link linkend="beans-factory">first part</link> covering the basic principles
		that apply to both the <interfacename>BeanFactory</interfacename> and
		<interfacename>ApplicationContext</interfacename>, and with the
		<link linkend="context-introduction">second part</link>	covering those features
		that apply only to the <interfacename>ApplicationContext</interfacename> interface.</para>
    </section>
    <section id="beans-basics">
        <title>Basics - containers and beans</title>
		<para>In Spring, those objects that form the backbone of your application and that
		are managed by the Spring IoC container are referred to as <firstterm>beans</firstterm>.
		A bean is simply an object that typically is instantiated, assembled and otherwise
		managed by a Spring IoC <firstterm>container</firstterm>; other than that, there is
		nothing special about a bean (it is in all other respects one of probably many objects
		in your application). These beans, and the <firstterm>dependencies</firstterm> between
		them, are reflected in the <firstterm>configuration metadata</firstterm> used by a
		container.</para>
		<sidebar>
			<title>Why... <emphasis>bean</emphasis>?</title>
			<para>The motivation for using the name <emphasis>'bean'</emphasis>, as opposed
			to <emphasis>'component'</emphasis> or <emphasis>'object'</emphasis> is rooted
			in the origins of the Spring Framework itself (it arose partly as a response to
			the complexity of Enterprise Java<emphasis>Beans</emphasis>).</para>
		</sidebar>
        <section id="beans-factory">
            <title>The container</title>
            <para>The <interfacename>org.springframework.beans.factory.BeanFactory</interfacename>
            is the actual representation of the Spring IoC <emphasis>container</emphasis> that is
            responsible for containing and otherwise managing the aforementioned beans.</para>
            <para>The <interfacename>BeanFactory</interfacename> interface is the central IoC container
            interface in Spring. Its responsibilities include instantiating or sourcing application
            objects, configuring said objects, and assembling the dependencies between these objects.</para>
			<para>There are a number of implementations of the <interfacename>BeanFactory</interfacename>
			interface that come supplied straight out-of-the-box with Spring. The most commonly used
			<interfacename>BeanFactory</interfacename> implementation is the
			<classname>XmlBeanFactory</classname> class. This implementation allows you to express the
			objects that compose your application, and the doubtless rich interdependencies between such
			objects, in terms of XML. The <classname>XmlBeanFactory</classname> takes this
			XML <firstterm>configuration metadata</firstterm> and uses it to create a
			fully configured system or application.</para>
			<para>
				<mediaobject>
					<imageobject role="fo">
						<imagedata fileref="images/container-magic.png" format="PNG" align="center" />
					</imageobject>
					<imageobject role="html">
						<imagedata fileref="images/container-magic.png" format="PNG" align="center" />
					</imageobject>
					<caption>
						<para>The Spring IoC container</para>
					</caption>
				</mediaobject>
			</para>
			<section>
				<title>Configuration metadata</title>
				<para>
					As can be seen in the above image, the Spring IoC container consumes some form of
					<emphasis>configuration metadata</emphasis>; this configuration metadata is nothing
					more than how you (as an application developer) inform the Spring container as to
					how to <quote><emphasis>instantiate, configure, and assemble [the objects in your
					application]</emphasis></quote>. This configuration metadata is typically supplied in a
					simple and intuitive XML format. When using XML-based configuration metadata, you
					write <emphasis>bean definitions</emphasis> for those beans that you want the
					Spring IoC container to manage, and then let said container do its stuff.
				</para>
				<note>
					<para>XML-based metadata is by far the most commonly used form of configuration
					metadata. It is <emphasis>not</emphasis> however the only form of
					configuration metadata that is allowed. The Spring IoC container itself
					is <emphasis>totally</emphasis> decoupled from the format in which this
					configuration metadata is actually written.</para>
					<para>At the time of writing, one can supply this configuration metadata
					using either XML, the Java properties format, or programmatically (using
					Spring's public API). The XML-based configuration metadata format really is
					simple though, and so the remainder of this chapter will use the XML format
					to convey key concepts and features of the Spring IoC container.</para>
				</note>
			</section>
				<sidebar>
					<title>Resources</title>
					<para>
						Once you have learned the basics of the IoC container (this chapter),
						it will also be useful to learn about Spring's
						<interfacename>Resource</interfacename> abstraction, as described in
						<xref linkend="resources" />.
					</para>
					<para>
						The location path or paths supplied to
						an <interfacename>ApplicationContext</interfacename> constructor are
						actually resource strings that allow the container to load
						configuration metadata from a variety of external resources such
						as the local file system, from the Java <literal>CLASSPATH</literal>, etc.
					</para>
				</sidebar>
				<para>Please be advised that in the vast majority of application scenarios,
				explicit user code is not required to instantiate one or more instances
				of a Spring IoC container. For example, in a web application scenario, a simple
				eight (or so) lines of absolutely boilerplate J2EE web descriptor XML in the
				attendant <literal>web.xml</literal> file of the application will typically
				suffice (see <xref linkend="context-create" />).</para>
			</section>
            <para>A Spring IoC container configuration consists of,
			at its most basic level, definitions of at least one (but typically more)
			beans that the container must manage. When using XML-based configuration metadata,
			these beans are configured as one or more <literal>&lt;bean/&gt;</literal> elements
			inside a top-level <literal>&lt;beans/&gt;</literal> element.</para>
			<para>These bean definitions correspond to the actual objects that make up your
			application(s). Typically one will have bean definitions for one's service layer
			objects, one's data access objects (DAOs), presentation objects such as Struts
			<interfacename>Action</interfacename> instances, infrastructure objects such as
			Hibernate <interfacename>SessionFactory</interfacename> instances, JMS
			<interfacename>Queue</interfacename> references, etc. (the possibilities are of
			course endless and are limited only by the scope and complexity of your	application).</para>
			<para>Find below an example of the basic structure of XML-based configuration
			metadata.</para>
			<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
  <bean id="..." class="...">
    ]]><lineannotation>&lt;!-- collaborators and configuration for this bean go here --&gt;</lineannotation><![CDATA[
  </bean>
  <bean id="..." class="...">
    ]]><lineannotation>&lt;!-- collaborators and configuration for this bean go here --&gt;</lineannotation><![CDATA[
  </bean>
  ]]><lineannotation>&lt;!-- more bean definitions go here... --&gt;</lineannotation><![CDATA[
</beans>]]></programlisting>
			<section>
				<title>Instantiating a container</title>
				<para>Instantiating a Spring IoC container is easy; find below some examples of how
				to do just that:</para>
				<programlisting><![CDATA[Resource resource = new FileSystemResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource);]]></programlisting>
				<para>... or...</para>
				<programlisting><![CDATA[ClassPathResource resource = new ClassPathResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(resource);]]></programlisting>
			    <para>... or...</para>
				<programlisting><![CDATA[ApplicationContext context = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
]]><lineannotation>// of course, an <interfacename>ApplicationContext</interfacename> is just a <interfacename>BeanFactory</interfacename></lineannotation><![CDATA[
BeanFactory factory = (BeanFactory) context;]]></programlisting>
                <section id="beans-factory-xml-import">
                    <title>Composing XML-based configuration metadata</title>
                    <para>It can often be useful to split up container definitions into multiple
			        XML files. One way to then load an application context which is configured
			        from all these XML fragments is to use the application context constructor
			        which takes multiple <interfacename>Resource</interfacename> locations. With
			        a bean factory, a bean definition reader can be used multiple times to read
			        definitions from each file in turn.</para>
                    <para>Generally, the Spring team prefers the above approach, since it
			        keeps container configuration files unaware of the fact that they are
			        being combined with others. An alternate approach is to use one or more
			        occurrences of the <literal>&lt;import/&gt;</literal> element to load bean definitions
			        from another file (or files). Any <literal>&lt;import/&gt;</literal> elements must be
			        placed before <literal>&lt;bean/&gt;</literal> elements in the file doing the importing. 
			        Let's look at a sample:</para>
		            <programlisting><![CDATA[<beans>

    <import resource="services.xml"/>
    <import resource="resources/messageSource.xml"/>
    <import resource="/resources/themeSource.xml"/>

    <bean id="bean1" class="..."/>
    <bean id="bean2" class="..."/>

</beans>]]></programlisting>
                <para>In this example, external bean definitions are being loaded from 3
			    files, <literal>services.xml</literal>,
			    <literal>messageSource.xml</literal>, and
			    <literal>themeSource.xml</literal>. All location paths are considered
			    relative to the definition file doing the importing, so
			    <literal>services.xml</literal> in this case must be in the same directory
			    or classpath location as the file doing the importing, while
			    <literal>messageSource.xml</literal> and
			    <literal>themeSource.xml</literal> must be in a
			    <literal>resources</literal> location below the location of the importing
			    file. As you can see, a leading slash is actually ignored, but given that
			    these are considered relative paths, it is probably better form not to use
			    the slash at all.</para>
                <para>The contents of the files being imported must be fully valid XML
			    bean definition files according to the Schema or DTD, including the
			    top level <literal>&lt;beans/&gt;</literal> element.</para>
            </section>
        </section>
        <section id="beans-definition">
            <title>The beans</title>
            <para>As mentioned previously, a Spring IoC container manages one or more
            <emphasis>beans</emphasis>. These beans are created using the instructions
            defined in the configuration metadata that has been supplied to the container
            (typically in the form of XML <literal>&lt;bean/&gt;</literal> definitions).</para>
            <para>Within the container itself, these bean definitions are represented as
            <interfacename>BeanDefinition</interfacename> objects, which contain (among other
            information) the following metadata:</para>
			<itemizedlist>
                <listitem>
                    <para><emphasis>a package-qualified class name:</emphasis> this is
					normally the actual implementation class of the bean being defined.
					However, if the bean is to be instantiated by invoking a
					<literal>static</literal> <emphasis>factory</emphasis> method
					instead of using a normal constructor, this will actually be the
					class name of the factory class.</para>
                </listitem>
                <listitem>
                    <para>bean behavioral configuration elements, which state how the
					bean should behave in the container (i.e. prototype or singleton,
					autowiring mode, dependency checking mode, initialization and
					destruction methods)</para>
                </listitem>
                <listitem>
                    <para>constructor arguments and property values to set in the
					newly created bean. An example would be the number of connections
					to use in a bean that manages a connection pool (either specified
					as a property or as a constructor argument), or the pool size
					limit.</para>
                </listitem>
                <listitem>
                    <para>other beans a bean needs to do its work, i.e.
                    <emphasis>collaborators</emphasis> (also called dependencies).</para>
                </listitem>
            </itemizedlist>
            <para>The concepts listed above directly translate to a set of properties
			that each bean definition consists of. Some of these properties are listed
			below, along with a link to further documentation about each of them.</para>
			<table>
                <title>The bean definition</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="2*" />
                    <colspec colname="c2" colwidth="4*" />
                    <thead>
                        <row>
                            <entry>Feature</entry>
                            <entry>Explained in...</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>class</entry>
                            <entry>
                                <para><xref linkend="beans-factory-class" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>name</entry>
                            <entry>
                                <para><xref linkend="beans-beanname" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>scope</entry>
                            <entry>
                                <para><xref linkend="beans-factory-scopes" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>constructor arguments</entry>
                            <entry>
                                <para><xref linkend="beans-factory-collaborators" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>properties</entry>
                            <entry>
                                <para><xref linkend="beans-factory-collaborators" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>autowiring mode</entry>
                            <entry>
                                <para><xref linkend="beans-factory-autowire" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>dependency checking mode</entry>
                            <entry>
                                <para><xref linkend="beans-factory-dependencies" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>lazy-initialization mode</entry>
                            <entry>
                                <para><xref linkend="beans-factory-lazy-init" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>initialization method</entry>
                            <entry>
                                <para><xref linkend="beans-factory-lifecycle" /></para>
                            </entry>
                        </row>
                        <row>
                            <entry>destruction method</entry>
                            <entry>
                                <para><xref linkend="beans-factory-lifecycle" /></para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
			<para>Besides bean definitions which contain information on how to
			create a specific bean, certain <interfacename>BeanFactory</interfacename>
			implementations also permit the registration of existing objects that have
			been created outside the factory (by user code). The
			<classname>DefaultListableBeanFactory</classname> class supports this
			through the <methodname>registerSingleton(..)</methodname> method. Typical applications
			solely work with beans defined through metadata bean definitions, though.</para>
            <section id="beans-beanname">
                <title>Naming beans</title>
                <sidebar>
                    <title>Bean naming conventions</title>
                    <para>The convention (at least amongst the Spring development team) is to use
				    the standard Java convention for instance field names when naming beans.
				    That is, bean names start with a lowercase letter, and are camel-cased
				    from then on. Examples of such names would be (without quotes)
				    <literal>'accountManager'</literal>, <literal>'accountService'</literal>,
				    <literal>'userDao'</literal>, <literal>'loginController'</literal>, etc.</para>
				    <para>Adopting a consistent way of naming your beans will go a long way towards
				    making your configuration easier to read and understand; adopting such
				    naming standards is not hard to do, and if you are using Spring AOP it
				    can pay off handsomely when it comes to applying advice to a set of
				    beans related by name.</para>
                </sidebar>
                <para>Every bean has one or more ids (also called identifiers, or names;
				these terms refer to the same thing). These ids must be unique within
				the container the bean is hosted in. A bean will almost always have only one
				id, but if a bean has more than one id, the extra ones can essentially be
				considered aliases.</para>
                <para>When using XM-based configuration metadata, you use the <literal>'id'</literal>
				or <literal>'name'</literal> attributes to specify the bean identifier(s). The
				<literal>'id'</literal> attribute allows you to specify exactly one id, and as
				it is a real XML element ID attribute, the XML parser is able to do
				some extra validation when other elements reference the id; as such, it is the
				preferred way to specify a bean id. However, the XML specification does limit
				the characters which are legal in XML IDs. This is usually not a constraint, but
				if you have a need to use one of these special XML characters, or want to introduce
				other aliases to the bean, you may also or instead specify one or more bean ids,
				separated by a comma (<literal>,</literal>), semicolon (<literal>;</literal>), or
				whitespace in the <literal>'name'</literal> attribute.</para>
                <para>Please note that you are not required to supply a name for a bean. If
				no name is supplied explicitly, the container will generate a (unique) name
				for that bean. The motivations for not supplying a name for a bean will be
				discussed later (one use case is <link linkend="beans-inner-beans">inner beans</link>).</para>
                <section id="beans-beanname-alias">
                    <title>Aliasing beans</title>
                    <para>In a bean definition itself, you may supply more than one name for
                    the bean, by using a combination of up to one name specified via the
                    <literal>id</literal> attribute, and any number of other names via the
                    <literal>alias</literal> attribute. All these names can be considered
                    equivalent aliases to the same bean, and are useful for some situations,
                    such as allowing each component used in an application to refer to a
                    common dependency using a bean name that is specific to that component
                    itself.</para>
                    <para>Having to specify all aliases when the bean is actually defined is not
                    always adequate however. It is sometimes desirable to introduce an alias
                    for a bean which is defined elsewhere. In XML-based configuration metadata
                    this may be accomplished via the use of the standalone
                    <literal>&lt;alias/&gt;</literal> element. For example:</para>
                    <programlisting><![CDATA[<alias name="fromName" alias="toName"/>]]></programlisting>
                    <para>In this case, a bean in the same container which is named
                    <literal>'fromName'</literal>, may also after the use of this alias
                    definition, be referred to as <literal>'toName'</literal>.</para>
                    <para>As a concrete example, consider the case where component A defines a
                    DataSource bean called componentA-dataSource, in its XML fragment.
                    Component B would however like to refer to the DataSource as
                    componentB-dataSource in its XML fragment. And the main application,
                    MyApp, defines its own XML fragment and assembles the final application
                    context from all three fragments, and would like to refer to the
                    DataSource as myApp-dataSource. This scenario can be easily handled by
                    adding to the MyApp XML fragment the following standalone aliases:</para>

                    <programlisting><![CDATA[<alias name="componentA-dataSource" alias="componentB-dataSource"/>
<alias name="componentA-dataSource" alias="myApp-dataSource" />]]></programlisting>

                    <para>Now each component and the main app can refer to the dataSource via
                    a name that is unique and guaranteed not to clash with any other
                    definition (effectively there is a namespace), yet they refer to the same
                    bean.</para>
                </section>
            </section>
            <section id="beans-factory-class">
                <title>Instantiating beans</title>
                <para>So far as a Spring IoC container is concerned, a bean definition
                is basically a recipe for creating one or more actual objects. The 
                container looks at the recipe for a named bean when asked, and uses
                the configuration metadata encapsulated by that bean definition to
                go off and reflectively create an actual object. This section is thus
                concerned with communicating to you, the application developer, how you
                inform a Spring IoC container both what type (or class) of object to
                instantiate and how to instantiate the resulting object.</para>
                <para>If you are using XML-based configuration metadata, you can specify
                the type (or class) of object that is to be instantiated using the
                <literal>'class'</literal> attribute of the <literal>&lt;bean/&gt;</literal>
                element. This <literal>'class'</literal> attribute (which internally
                eventually boils down to being a <classname>Class</classname> property on a
                <interfacename>BeanDefinition</interfacename> instance) is normally
                mandatory (see <xref linkend="beans-factory-class-instance-factory-method" /> and
			    <xref linkend="beans-child-bean-definitions" /> for the two exceptions)
			    and is used for one of two purposes. The class property specifies the
			    class of the bean to be constructed in the much more common case where the
			    container itself directly creates the bean by calling its constructor
			    reflectively (somewhat equivalent to Java code using the
			    <emphasis>'new'</emphasis> operator). In the less common case where the
			    container invokes a <literal>static</literal>, <emphasis>factory</emphasis>
			    method on a class to create the bean, the class property specifies the actual
			    class containing the <literal>static</literal> factory method that is to
			    be invoked to create the object (the type of the object returned from the
			    invocation of the <literal>static</literal> factory method may be the same
			    class or another class entirely, it doesn't	matter).</para>
                <section id="beans-factory-class-ctor">
                    <title>Instantiation using a constructor</title>
                    <para>When creating a bean using the constructor approach, all normal
				    classes are usable by and compatible with Spring. That is, the
				    class being created does not need to implement any specific interfaces
				    or be coded in a specific fashion. Just specifying the bean class
				    should be enough. However, depending on what type of IoC you are going
				    to use for that specific bean, you may need a default (empty)
				    constructor.</para>
                    <para>Additionally, the Spring IoC container isn't limited to just managing
				    true JavaBeans, it is also able to manage virtually <emphasis>any</emphasis>
				    class you want it to manage. Most people using Spring prefer to
				    have actual JavaBeans (having just a default (no-argument) constructor
				    and appropriate setters and getters modeled after the properties)
				    in the container, but it is also possible to have more exotic
				    non-bean-style classes in your container. If, for example, you
				    need to use a legacy connection pool that absolutely does not adhere
				    to the JavaBean specification, Spring can manage it as well.</para>
                    <para>When using XML-based configuration metadata you can specify your bean
				    class like so:</para>
				    <programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean"/>

<bean name="anotherExample" class="examples.ExampleBeanTwo"/>]]></programlisting>
                    <para>The mechanism for supplying arguments to the constructor (if required),
				    or setting properties of the object instance after it has been constructed,
				    will be described shortly.</para>
                </section>
                <section id="beans-factory-class-static-factory-method">
                    <title>Instantiation using a <literal>static</literal> factory method</title>
                    <para>
					    When defining a bean which is to be created using a static
					    factory method, along with the <literal>class</literal> attribute
					    which specifies the class containing the <literal>static</literal> factory method,
					    another attribute named <literal>factory-method</literal> is needed to
					    specify the name of the factory method itself. Spring expects to be
					    able to call this method (with an optional list of arguments as
					    described later) and get back a live object, which from that point on
					    is treated as if it had been created normally via a constructor. One
					    use for such a bean definition is to call <literal>static</literal>
					    factories in legacy code.
				    </para>
                    <para>
					    The following example shows a bean definition which specifies
					    that the bean is to be created by calling a factory-method. Note that
					    the definition does not specify the type (class) of the returned
					    object, only the class containing the factory method. In this example,
					    the <methodname>createInstance()</methodname> method must be a
					    <emphasis>static</emphasis> method.
				    </para>
				    <programlisting><![CDATA[<bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/>]]></programlisting>
                    <para>The mechanism for supplying (optional) arguments to the factory
				    method, or setting properties of the object instance after it has been
				    returned from the factory, will be described shortly.</para>
                </section>
                <section id="beans-factory-class-instance-factory-method">
                    <title>Instantiation using an instance factory method</title>
                    <para>In a fashion similar to instantiation via a
                    <link linkend="beans-factory-class-static-factory-method">static factory method</link>,
                    instantiation using an instance factory method is where the factory method of an
                    existing bean from the container is invoked to create the new bean.</para>
                    <para>To use this mechanism, the <literal>'class'</literal> attribute
				    must be left empty, and the <literal>'factory-bean'</literal> attribute
				    must specify the name of a bean in the current or an ancestor bean
				    factory which contains the factory method. The factory method itself
				    should still be set via the <literal>'factory-method'</literal>
				    attribute (as seen in the example below).</para>
                    <programlisting><lineannotation>&lt;!-- the factory bean, which contains a method called <methodname>createInstance()</methodname> --&gt;</lineannotation><![CDATA[
<bean id="myFactoryBean" class="...">
  ...
</bean>

]]><lineannotation>&lt;!-- the bean to be created via the factory bean --&gt;</lineannotation><![CDATA[
<bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/>]]></programlisting>
                    <para>Although the mechanisms for setting bean properties are still to
				    be discussed, one implication of this approach is that the factory
				    bean itself can be managed and configured via DI.</para>
                </section>
            </section>
        </section>
        <section id="beans-factory-client">
            <title>Using the container</title>
            <para>A <interfacename>BeanFactory</interfacename> is essentially nothing more
            than the interface for an advanced factory capable of maintaining a registry
            of different beans and their dependencies. The <interfacename>BeanFactory</interfacename>
            enables you to read bean definitions and access them using the bean factory.
            When using just the <interfacename>BeanFactory</interfacename> you would create
            one and read in some bean definitions in the XML format as follows:</para>
            <programlisting><![CDATA[InputStream is = new FileInputStream("beans.xml");
BeanFactory factory = new XmlBeanFactory(is);]]></programlisting>
            <para>Basically that's all there is to it. Using <methodname>getBean(String)</methodname>
            you can retrieve instances of your beans; the client-side view of the
            <interfacename>BeanFactory</interfacename> is surprisingly simple. The
            <interfacename>BeanFactory</interfacename> interface has only six methods for
            client code to call:</para>
            <itemizedlist>
                <listitem>
                    <para><methodname>boolean containsBean(String)</methodname>: returns true
                    if the <interfacename>BeanFactory</interfacename> contains a bean
                    definition or bean instance that matches the given name</para>
                </listitem>
                <listitem>
                    <para><methodname>Object getBean(String)</methodname>: returns an instance
                    of the bean registered under the given name. Depending on how the
                    bean was configured by the <interfacename>BeanFactory</interfacename> configuration, either a
                    singleton and thus shared instance or a newly created bean will be
                    returned. A <exceptionname>BeansException</exceptionname> will be thrown when
                    either the bean could not be found (in which case it'll be a
                    <exceptionname>NoSuchBeanDefinitionException</exceptionname>), or an exception
                    occurred while instantiating and preparing the bean</para>
                </listitem>
                <listitem>
                    <para><methodname>Object getBean(String, Class)</methodname>: returns a
                    bean, registered under the given name. The bean returned will be
                    cast to the given Class. If the bean could not be cast,
                    corresponding exceptions will be thrown
                    (<exceptionname>BeanNotOfRequiredTypeException</exceptionname>). Furthermore,
                    all rules of the <methodname>getBean(String)</methodname> method apply (see above)</para>
                </listitem>
                <listitem>
                    <para><methodname>Class getType(String name)</methodname>: returns the
                    <classname>Class</classname> of the bean with the given name. If no bean
                    corresponding to the given name could be found, a
                    <exceptionname>NoSuchBeanDefinitionException</exceptionname> will be thrown</para>
                </listitem>
                <listitem>
                    <para><methodname>boolean isSingleton(String)</methodname>: determines
                    whether or not the bean definition or bean instance registered under
                    the given name is a singleton (bean scopes such as singleton are explained
                    <link linkend="beans-factory-scopes">later</link>). If no bean corresponding
                    to the given name could be found, a
                    <exceptionname>NoSuchBeanDefinitionException</exceptionname> will be thrown</para>
                </listitem>
                <listitem>
                    <para><methodname>String[] getAliases(String)</methodname>: Return the
                    aliases for the given bean name, if any were defined in the bean
                    definition</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section id="beans-dependencies">
        <title>Dependencies</title>
        <para>Your typical enterprise application is not made up of a single object (or
        bean in the Spring parlance). Even the simplest of applications will no doubt
        have at least a handful of objects that work together to present what the
        end-user sees as a coherent application. This next section explains how you go
        from defining a number of bean definitions that stand-alone, each to themselves,
        to a fully realized application where objects work (or collaborate) together
        to achieve some goal (usually an application that does what the end-user wants).</para>
        <section id="beans-factory-collaborators">
            <title>Injecting dependencies</title>
            <para>
				The basic principle behind <emphasis>Dependency Injection</emphasis> (DI)
				is that objects define their dependencies (i.e. the other objects they work
				with) only through constructor arguments, arguments to a factory method, or
				properties which are set on the object instance after it has been
				constructed or returned from a factory method. Then, it is the job of
				the container to actually <emphasis>inject</emphasis> those dependencies
				when it creates the bean. This is fundamentally the inverse, hence the
				name <emphasis>Inversion of Control</emphasis> (IoC), of the bean itsel
				 being in control of instantiating or locating its dependencies on its
				 own using direct construction of classes, or something like the
				<emphasis>Service Locator</emphasis> pattern.
			</para>
			<para>
				It becomes evident upon usage that code gets much cleaner when the DI
				principle is applied, and reaching a higher grade of decoupling is much
				easier when beans do not look up their dependencies, but are provided
				with them (and additionally do not even know where the dependencies are
				located and of what actual class they are).
			</para>
            <para>
				As touched on in the previous paragraph, DI exists in two major variants,
				namely <link linkend="beans-setter-injection">Setter Injection</link>, and
				<link linkend="beans-constructor-injection">Constructor Injection</link>.
			</para>
			<section id="beans-setter-injection">
				<title>Setter Injection</title>
                <para>
					<emphasis>Setter-based</emphasis> DI is realized by calling setter methods
					on your beans after invoking a no-argument constructor or no-argument
					<literal>static</literal> factory method to instantiate your bean.
				</para>
				<para>
					Find below an example of a class that can only be dependency injected
					using pure setter injection. Note that there is nothing
					<emphasis>special</emphasis> about this class... it is plain old Java.
				</para>
				<programlisting><![CDATA[public class SimpleMovieLister {

    ]]><lineannotation>// the <classname>SimpleMovieLister</classname> has a dependency on the <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    private MovieFinder movieFinder;

    ]]><lineannotation>// a setter method so that the Spring container can 'inject' a <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    public void setMoveFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    ]]><lineannotation>// business logic that actually 'uses' the injected <interfacename>MovieFinder</interfacename> is omitted...</lineannotation><![CDATA[
}]]></programlisting>
			</section>
			<section id="beans-constructor-injection">
				<title>Constructor Injection</title>
                <para>
					<emphasis>Constructor-based</emphasis> DI
					is realized by invoking a constructor with a number of arguments,
					each representing a collaborator. Additionally,
					calling a <literal>static</literal> factory method with specific
					arguments to construct the bean, can be considered almost equivalent,
					and the rest of this text will consider arguments to a constructor and
					arguments to a <literal>static</literal> factory method similarly.
				</para>
				<para>
					Find below an example of a class that could only be dependency injected
					using constructor injection. Again, note that there is nothing
					<emphasis>special</emphasis> about this class.
				</para>
				<programlisting><![CDATA[public class SimpleMovieLister {

    ]]><lineannotation>// the <classname>SimpleMovieLister</classname> has a dependency on the <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    private MovieFinder movieFinder;

    ]]><lineannotation>// a constructor so that the Spring container can 'inject' a  <interfacename>MovieFinder</interfacename></lineannotation><![CDATA[
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    ]]><lineannotation>// business logic that actually 'uses' the injected <interfacename>MovieFinder</interfacename> is omitted...</lineannotation><![CDATA[
}]]></programlisting>
			</section>
			<sidebar>
				<title>Constructor- or Setter-based DI?</title>
				<para>
					The Spring team generally advocates the usage of setter injection,
					since a large number of constructor arguments can get unwieldy,
					especially when some properties are optional. The presence of
					setter methods also makes objects of that class amenable to being
					re-configured (or re-injected) at some later time (for management
					via <link linkend="jmx">JMX MBeans</link> is a particularly
					compelling use case).
				</para>
				<para>
					Constructor-injection is favored by some purists though (and with
					good reason). Supplying all of an object's dependencies means that
					that object is never returned to client (calling) code in a less than
					totally initialized state. The flipside is that the object becomes
					less amenable to re-configuration (or re-injection).
				</para>
				<para>
					There is no hard and fast rule here. Use whatever type of DI makes
					the most sense for a particular class; sometimes, when dealing with
					third party classes to which one does not have the source, the choice
					will already have been made for you - a legacy class may not expose
					any setter methods, and so constructor injection will be the only type
					of DI available to you.
				</para>
			</sidebar>
            <para>
				The <interfacename>BeanFactory</interfacename> supports both of these
				variants for injecting dependencies into beans it manages. (It in fact
				also supports injecting setter-based dependencies after some
				dependencies have already been supplied via the constructor approach.)
				The configuration for the dependencies comes in the form of a
				<interfacename>BeanDefinition</interfacename>, which is used together with
				<interfacename>PropertyEditor</interfacename> instances to know how to
				convert properties from one format to another. However, most users of
				Spring will not be dealing with these classes directly
				(i.e. programmatically), but rather with an XML definition file which
				will be converted internally into instances of these classes, and used
				to load an entire Spring IoC container instance.
			</para>
            <para>
				Bean dependency resolution generally happens as follows:
			</para>
			<orderedlist>
                <listitem>
                    <para>
						The <interfacename>BeanFactory</interfacename> is created
						and initialized with a configuration which describes all
						the beans. (Most Spring users use a
						<interfacename>BeanFactory</interfacename> or
						<interfacename>ApplicationContext</interfacename> implementation
						that supports XML format configuration files.)
					</para>
                </listitem>
                <listitem>
                    <para>
						Each bean has dependencies expressed in the form of
						properties, constructor arguments, or arguments to the
						static-factory method when that is used instead of a normal
						constructor. These dependencies will be provided to the bean,
						<emphasis>when the bean is actually created</emphasis>.
					</para>
                </listitem>
                <listitem>
                    <para>
						Each property or constructor argument is either an actual
						definition of the value to set, or a reference to another bean in
						the container.
					</para>
                </listitem>
                <listitem>
                    <para>
						<anchor id="beans-factory-collaborators-propertyeditor" />
						Each property or constructor argument which is a value must
						be able to be converted from whatever format it was specified
						in, to the actual type of that property or constructor argument.
						By default Spring can convert a value supplied in string format
						to all built-in types, such as <literal>int</literal>,
						<literal>long</literal>, <literal>String</literal>,
						<literal>boolean</literal>, etc.
					</para>
                </listitem>
            </orderedlist>
            <para>
				It is important to realize that Spring validates the
				configuration of each bean in a container as the container
				is created, including the validation that properties which are
				bean references are actually referring to valid beans (i.e. the
				beans being referred to are also defined in the container.
				However, the bean properties themselves are not set until the
				bean <emphasis>is actually created</emphasis>. For that which
				are singleton-scoped and set to be pre-instantiated (such as
				singleton beans in an <interfacename>ApplicationContext</interfacename>),
				creation happens at the time that the container is created, but
				otherwise this is only when the bean is requested. When a bean
				actually has to be created, this will potentially cause a graph
				of other beans to be created, as its dependencies and its
				dependencies' dependencies (and so on) are created and assigned.
			</para>
			<sidebar>
			    <title>Circular dependencies</title>
			    <para>If you are using predominantly constructor injection it is
			    possible to write and configure your classes and beans such that
			    an unresolvable circular dependency scenario is created.</para>
			    <para>Consider the scenario where you have class A, which requires
			    an instance of class B to be provided via constructor injection,
			    and class B, which requires an instance of class A to be provided
			    via constructor injection. If you configure beans for classes A and B
			    to be injected into each other, the Spring IoC container will detect
			    this circular reference at runtime, and throw a
			    <classname>BeanCurrentlyInCreationException</classname>.</para>
			    <para>One possible solution to this issue is to edit the source code of
			    some of your classes to be configured via setters instead of via
			    constructors. Another solution is to totally forego the use of
			    constructor injection.</para>
			</sidebar>
            <para>
				You can generally trust Spring to do the right thing. It
				will detect mis-configuration issues, such as references to
				non-existent beans and circular dependencies, at container
				load-time. It will actually set properties and resolve
				dependencies (i.e. create those dependencies if needed) as late as
				possible, which is when the bean is actually created. This does
				mean that a Spring container which has loaded correctly, can later
				generate an exception when you request a bean, if there is a
				problem creating that bean or one of its dependencies. This could
				happen if the bean throws an exception as a result of a missing or
				invalid property, for example. This potentially delayed visibility
				of some configuration issues is why
				<interfacename>ApplicationContext</interfacename> implementations by default
				pre-instantiate singleton beans. At the cost of some upfront time
				and memory to create these beans before they are actually needed,
				you find out about configuration issues when the
				<interfacename>ApplicationContext</interfacename> is created, not later.
				If you wish, you can still override this default behavior and set any of these
				singleton beans to lazy-initialize (i.e. not be pre-instantiated).
			</para>
            <para>
				Finally, if it is not immediately apparent, it is worth mentioning that when
				one or more collaborating beans are being injected into a dependent bean, each
				collaborating bean is <emphasis>totally</emphasis> configured prior to being
				passed (via one of the DI flavors) to the dependent bean.
				This means that if bean A has a dependency on bean B, the Spring IoC container
				will <emphasis>totally</emphasis> configure bean B prior to invoking (for example)
				the attendant setter method on bean A; you can read '<emphasis>totally configure</emphasis>'
				to mean that the bean will be instantiated (if not a pre-instantiated singleton),
				all of its dependencies will be set, and the relevant lifecycle methods (such as
				a <link linkend="beans-factory-lifecycle-initializingbean">configured init method</link>
				or the
				<link linkend="beans-factory-lifecycle-initializingbean">IntializingBean callback method</link>
				will all be invoked.
			</para>
		<section id="beans-some-examples">
			<title>Some examples</title>
            <para>First, an example of using XML-based configuration metadata for setter-based DI.
			Find below a small part of a Spring XML configuration file specifying some bean
			definitions.</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">

  ]]><lineannotation>&lt;!-- setter injection using the nested <literal>&lt;ref/&gt;</literal> element --&gt;</lineannotation><![CDATA[
  <property name="beanOne"><ref bean="anotherExampleBean"/></property>

  ]]><lineannotation>&lt;!-- setter injection using the neater 'ref' attribute --&gt;</lineannotation><![CDATA[
  <property name="beanTwo"><ref bean="yetAnotherBean"/></property>
  <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}]]></programlisting>
			<para>As you can see, setters have been declared to match against the properties
			specified in the XML file.</para>
            <para>Now, an example of using constructor-based DI. Find below a snippet from an XML
            configuration that specifies constructor arguments, and the corresponding Java class.</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">

  ]]><lineannotation>&lt;!-- constructor injection using the nested <literal>&lt;ref/&gt;</literal> element --&gt;</lineannotation><![CDATA[
  <constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
  
  ]]><lineannotation>&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</lineannotation><![CDATA[
  <constructor-arg ref="yetAnotherBean"/>
  
  <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}]]></programlisting>
			<para>
				As you can see, the constructor arguments specified in the
				bean definition will be used to pass in as arguments to the constructor
				of the <classname>ExampleBean</classname>.
			</para>
            <para>
				Now consider a variant of this where instead of using a
				constructor, Spring is told to call a <literal>static</literal> factory
				method to return an instance of the object:
			</para>
			<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance">
  <constructor-arg><ref bean="anotherExampleBean"/></constructor-arg>
  <constructor-arg><ref bean="yetAnotherBean"/></constructor-arg>
  <constructor-arg><value>1</value></constructor-arg>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>]]></programlisting>
			<programlisting><![CDATA[public class ExampleBean {

    ]]><lineannotation>// a private constructor</lineannotation><![CDATA[
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean (...);
        // some other operations
        ...
        return eb;
    }
}]]></programlisting>
            <para>
				Note that arguments to the <literal>static</literal> factory method
				are supplied via <literal>constructor-arg</literal> elements, exactly
				the same as if a constructor had actually been used. Also, it is
				important to realize that the type of the class being returned by
				the factory method does not have to be of the same type as the class
				which contains the <literal>static</literal> factory method, although
				in this example it is. An instance (non-static) factory method would
				be used in an essentially identical fashion (aside from the use of the
				<literal>factory-bean</literal> attribute instead of the
				<literal>class</literal> attribute), so will not be detailed here.
			</para>
        </section>
		</section>
        <section>
            <title>Constructor Argument Resolution</title>
            <para>
				Constructor argument resolution matching occurs using the
				argument's type. If there is no potential for ambiguity in
				the constructor arguments of a bean definition, then the order
				in which the constructor arguments are defined in a bean definition
				is the order in which those arguments will be supplied to the
				appropriate constructor when it is being instantiated. Consider the
				following class...
			</para>
			<programlisting><![CDATA[package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}]]></programlisting>
			<para>
				There is no potential for ambiguity here (assuming of course that <classname>Bar</classname>
				and <classname>Baz</classname> classes are not related in an inheritance hierarchy).
				Thus the following configuration will work just fine, and one does not need to
				specify the constructor argument indexes and / or types explicitly... it just plain
				works as one would expect it to.
			</para>
			<programlisting><![CDATA[<beans>
    <bean name="foo" class="x.y.Foo">
        <constructor-arg>
            <bean class="x.y.Bar"/>
        </constructor-arg>
        <constructor-arg>
            <bean class="x.y.Baz"/>
        </constructor-arg>
    </bean>
</beans>]]></programlisting>
			<para>
				When another bean is referenced, the type is known, and
				matching can occur (as was the case with the preceding example).
				When a simple type is used, such as
				<literal>&lt;value&gt;true&lt;value&gt;</literal>, Spring cannot
				determine the type of the value, and so cannot match by type without
				help. Consider the following class, which is used for the following two
				sections:
			</para>
			<programlisting><![CDATA[package examples;

public class ExampleBean {

    ]]><lineannotation>// No. of years to the calculate the Ultimate Answer</lineannotation><![CDATA[
    private int years;
    
    ]]><lineannotation>// The Answer to Life, the Universe, and Everything</lineannotation><![CDATA[
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}]]></programlisting>
            <section>
                <title>Constructor Argument Type Matching</title>
                <para>The above scenario <emphasis>can</emphasis> use type matching
				with simple types by explicitly specifying the type of the constructor
				argument using the <literal>'type'</literal> attribute. For example:</para>
				<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg type="int"><value>7500000</value></constructor-arg>
  <constructor-arg type="java.lang.String"><value>42</value></constructor-arg>
</bean>]]></programlisting>
            </section>
            <section>
                <title>Constructor Argument Index</title>
                <para>Constructor arguments can have their index specified explicitly by use of
                the <literal>index</literal> attribute. For example:</para>
				<programlisting><![CDATA[<bean id="exampleBean" class="examples.ExampleBean">
  <constructor-arg index="0" value="7500000"/>
  <constructor-arg index="1" value="42"/>
</bean>]]></programlisting>
				<para>As well as solving the ambiguity problem of multiple simple values, specifying
				an index also solves the problem of	ambiguity where a constructor may have two
				arguments of the same type.	Note that the <emphasis>index is 0 based</emphasis>.</para>
				<tip>
                    <para>Specifying a constructor argument index is the preferred way of performing
                    constructor IoC.</para>
				</tip>
            </section>
        </section>
        <section id="beans-factory-properties-detailed">
            <title>Bean properties and constructor arguments detailed</title>
            <para>As mentioned in the previous section, bean properties and
            constructor arguments can be defined as either references to other
            managed beans (collaborators), or values defined inline. Springs XML-based
            configuration metadata supports a number of sub-element types
            within its <literal>&lt;property/&gt;</literal> and
            <literal>&lt;constructor-arg/&gt;</literal> elements for just this purpose.</para>
            <section id="beans-value-element">
                <title>Straight values (primitives, <literal>Strings</literal>, etc.)</title>
                <para>The <literal>&lt;value/&gt;</literal> element specifies a property or
				constructor argument as a human-readable string representation. As
				mentioned in detail <link linkend="beans-factory-collaborators-propertyeditor">previously</link>,
				JavaBeans <literal>PropertyEditors</literal> are used to convert these
				string values from a <classname>java.lang.String</classname> to the
				actual property or argument type.</para>
			    <programlisting><![CDATA[<bean id="myDataSource" destroy-method="close"
    class="org.apache.commons.dbcp.BasicDataSource">
  ]]><lineannotation>&lt;!-- results in a <methodname>setDriverClassName(String)</methodname> call --&gt;</lineannotation><![CDATA[
  <property name="driverClassName">
    <value>com.mysql.jdbc.Driver</value>
  </property>
  <property name="url">
    <value>jdbc:mysql://localhost:3306/mydb</value>
  </property>
  <property name="username">
    <value>root</value>
  </property>
</bean>]]></programlisting>
            <section id="beans-idref-element">
                <title>The <literal>idref</literal> element</title>
                <para>
                The <literal>idref</literal> element is simply an error-proof way to
                pass the <emphasis>id</emphasis> of another bean in the container (to
                a <literal>&lt;constructor-arg/&gt;</literal> or <literal>&lt;property/&gt;</literal>
                element).</para>
                <programlisting><![CDATA[<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean" />
    </property>
</bean>]]></programlisting>
        <para>
            The above bean definition snippet is <emphasis>exactly</emphasis> equivalent
            (at runtime) to the following snippet:
        </para>
        <programlisting><![CDATA[<bean id="theTargetBean" class="..."/>

<bean id="client" class="...">
    <property name="targetName">
        <value>theTargetBean</value>
    </property>
</bean>]]></programlisting>
		<para>The main reason the first form is preferable to
        the second is that using the <literal>idref</literal> tag allows the
        container to validate <emphasis>at deployment time</emphasis> that the
        referenced, named bean actually exists. In the second variation,
        no validation is performed on the value that is passed to the
        <literal>'targetName'</literal> property of the <literal>'client'</literal>
        bean. Any typo will only be discovered (with most likely fatal results)
        when the <literal>'client'</literal> bean is actually instantiated...
        if the <literal>'client'</literal> bean is a
        <link linkend="beans-factory-scopes">prototype</link> bean, this typo
        (and the resulting exception) may only be discovered long after the
        container is actually deployed.</para>
        <para>Additionally, if the bean being referred to is in the same XML unit, and
        the bean name is the bean <emphasis>id</emphasis>, the <literal>'local'</literal>
        attribute may be used, which allows the XML parser itself to validate the bean
        id even earlier, at XML document parse time.</para>
        <programlisting><![CDATA[<property name="targetName">
   ]]><lineannotation>&lt;!-- a bean with an id of 'target' must exist, else an XML exception will be thrown --&gt;</lineannotation><![CDATA[
   <idref local="theTargetBean"/>
</property>]]></programlisting>
        <para>By way of an example, one common place (at least in pre-Spring 2.0
        configuration) where the &lt;idref/&gt; element brings value is in the
        configuration of <link linkend="aop-pfb-1">AOP interceptors</link> in a
        <classname>ProxyFactoryBean</classname> bean definition. If one uses
        &lt;idref/&gt; elements when specifying the interceptor names, there is
        no chance of inadvertently misspelling an interceptor id.</para>
            </section>
            </section>
            <section id="beans-ref-element">
                <title>References to other beans (collaborators)</title>
                <para>The <literal>ref</literal> element is the final element allowed
                inside a <literal>&lt;constructor-arg/&gt;</literal> or
                <literal>&lt;property/&gt;</literal> definition element. It is used to
                set the value of the specified property to be a reference to another
                bean managed by the container (a collaborator). As
                mentioned in a previous section, the referred-to bean is considered to
                be a dependency of the bean who's property is being set, and will be
                initialized on demand as needed (if it is a singleton bean it may have
                already been initialized by the container) before the property is set.
                All references are ultimately just a reference to another object, but
                there are 3 variations on how the id/name of the other object may be
                specified, which determines how scoping and validation is handled.</para>
                <para>Specifying the target bean by using the <literal>bean</literal>
                attribute of the <literal>ref</literal> tag is the most general form,
                and will allow creating a reference to any bean in the same
                container (whether or not in the same XML file), or parent container.
                The value of the <literal>'bean'</literal> attribute may be the same as either the
                <literal>'id'</literal> attribute of the target bean, or one of the
                values in the <literal>'name'</literal> attribute of the target bean.</para>
                <programlisting><![CDATA[<ref bean="someBean"/>]]></programlisting>
                <para>Specifying the target bean by using the <literal>local</literal>
                attribute leverages the ability of the XML parser to validate XML id
                references within the same file. The value of the
                <literal>local</literal> attribute must be the same as the
                <literal>id</literal> attribute of the target bean. The XML parser
                will issue an error if no matching element is found in the same file.
                As such, using the local variant is the best choice (in order to know
                about errors are early as possible) if the target bean is in the same
                XML file.</para>
                <programlisting><![CDATA[<ref local="someBean"/>]]></programlisting>
                <para>Specifying the target bean by using the <literal>'parent'</literal>
                attribute allows a reference to be created to a bean which is in a
                parent container of the current container. The value of the
                <literal>'parent'</literal> attribute may be the same as either the
                <literal>'id'</literal> attribute of the target bean, or one of the
                values in the <literal>'name'</literal> attribute of the target bean,
                and the target bean must be in a parent container to the current one.
                The main use of this bean reference variant is when there is a need
                to wrap an existing bean in a parent context with some sort of proxy
                (which may have the same name as the parent), and needs the original
                object so it may wrap it.</para>
                <programlisting><![CDATA[<ref parent="someBean"/>]]></programlisting>
            </section>
            <section id="beans-inner-beans">
                <title>Inner beans</title>
                <para>A <literal>&lt;bean/&gt;</literal> element inside the
                <literal>&lt;property/&gt;</literal> or <literal>&lt;constructor-arg/&gt;</literal>
                elements is used to define a so-called <firstterm>inner bean</firstterm>. An
                inner bean definition does not need to have any id or name defined, and it is
                best not to even specify any id or name value because said id or name value
                will simply be ignored by the container.</para>
                <para>Find below an example of an inner bean.</para>
                <programlisting><![CDATA[<bean id="outer" class="...">
  ]]><lineannotation>&lt;!-- instead of using a reference to a target bean, simply define the target inline --&gt;</lineannotation><![CDATA[
  <property name="target">
    <bean class="com.mycompany.Person"> ]]><lineannotation>&lt;!-- this is the inner bean --&gt;</lineannotation><![CDATA[
      <property name="name" value="Fiona Apple"/>
      <property name="age" value="25"/>
    </bean>
  </property>
</bean>]]></programlisting>
                <para>Note that in the specific case of inner beans, the <literal>'singleton'</literal>
                flag and any <literal>'id'</literal> or <literal>'name'</literal> attribute are
                effectively ignored. Inner beans are <emphasis>always</emphasis> anonymous and they
                are <emphasis>always</emphasis> scoped as
                <link linkend="beans-factory-scopes-prototype">prototypes</link>. Please also note
                that it is <emphasis>not</emphasis> possible to inject inner beans into
                collaborating beans other than into the enclosing bean.</para>
            </section>
            <section id="beans-collection-elements">
                <title>Collections</title>
                <para>The <literal>&lt;list/&gt;</literal>, <literal>&lt;set/&gt;</literal>,
                <literal>&lt;map/&gt;</literal>, and <literal>&lt;props/&gt;</literal> elements
                allow properties and arguments of the Java <interfacename>Collection</interfacename>
                type <interfacename>List</interfacename>, <interfacename>Set</interfacename>,
                <interfacename>Map</interfacename>, and <interfacename>Properties</interfacename>,
                respectively, to be defined and set.</para>

                <programlisting><![CDATA[<bean id="moreComplexObject" class="example.ComplexObject">
  ]]><lineannotation>&lt;!-- results in a setAdminEmails(<classname>java.util.Properties</classname>) call --&gt;</lineannotation><![CDATA[
  <property name="adminEmails">
    <props>
        <prop key="administrator">administrator@somecompany.org</prop>
        <prop key="support">support@somecompany.org</prop>
        <prop key="development">development@somecompany.org</prop>
    </props>
  </property>
  ]]><lineannotation>&lt;!-- results in a setSomeList(<interfacename>java.util.List</interfacename>) call --&gt;</lineannotation><![CDATA[
  <property name="someList">
    <list>
        <value>a list element followed by a reference</value>
        <ref bean="myDataSource" />
    </list>
  </property>
  ]]><lineannotation>&lt;!-- results in a setSomeMap(<interfacename>java.util.Map</interfacename>) call --&gt;</lineannotation><![CDATA[
  <property name="someMap">
    <map>
        <entry>
            <key>
                <value>yup an entry</value>
            </key>
            <value>just some string</value>
        </entry>
        <entry>
            <key>
                <value>yup a ref</value>
            </key>
            <ref bean="myDataSource" />
        </entry>
    </map>
  </property>
  ]]><lineannotation>&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</lineannotation><![CDATA[
  <property name="someSet">
    <set>
        <value>just some string</value>
        <ref bean="myDataSource" />
    </set>
  </property>
</bean>]]></programlisting>
                <para><emphasis>Note that the value of a map key or value, or a set value,
                can also again be any of the following elements:</emphasis></para>
                <programlisting><![CDATA[bean | ref | idref | list | set | map | props | value | null]]></programlisting>
                <section id="beans-collection-elements-merging">
                    <title>Collection merging</title>
                    <para>
                    As of Spring 2.0, the container also supports the <emphasis>merging</emphasis> of collections. This allows
                    an application developer to define a parent-style <literal>list</literal>, <literal>map</literal>,
                    <literal>set</literal> or <literal>props</literal> element, and have child-style
                    <literal>list</literal>, <literal>map</literal>, <literal>set</literal> or <literal>props</literal> elements
                    inherit and override values from the parent collection; i.e. the child collection's values will be the
                    result obtained from the merging of the elements of the parent and child collections, with the child's
                    collection elements overriding values specified in the parent collection.
                    </para>
                    <para><emphasis>Please note that this section on merging makes use of the
                    parent-child bean mechanism. This concept has not yet been introduced, so
                    readers unfamiliar with the concept of parent and child bean definitions
                    may wish to read the corresponding section before continuing (see the
                    section entitled <xref linkend="beans-child-bean-definitions" />).</emphasis></para>
                    <para>An example would perhaps serve best to illustrate this feature:</para>
                    <programlisting><![CDATA[<beans>
<bean id="parent" abstract="true" class="example.ComplexObject">
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@somecompany.com</prop>
            <prop key="support">support@somecompany.com</prop>
        </props>
    </property>
</bean>
<bean id="child" parent="parent">
    <property name="adminEmails">
        ]]><lineannotation>&lt;!-- the merge is specified on the *child* collection definition --&gt;</lineannotation><![CDATA[
        <props merge="true">
            <prop key="sales">sales@somecompany.com</prop>
            <prop key="support">support@somecompany.co.uk</prop>
        </props>
    </property>
</bean>
<beans>]]></programlisting>
                <para>Notice the use of the <literal>merge=true</literal> attribute on the
                <literal><![CDATA[<props/>]]></literal> element of the
                <literal>adminEmails</literal> property of the <literal>child</literal>
                bean definition. When the <literal>child</literal> bean is actually resolved
                and instantiated by the container, the resulting instance will have an
                <literal>adminEmails</literal> <classname>Properties</classname> collection
                that contains the result of the merging of the child's
                <literal>adminEmails</literal> collection with the parent's
                <literal>adminEmails</literal> collection.</para>
                <programlisting><![CDATA[administrator=administrator@somecompany.com
sales=sales@somecompany.com
support=support@somecompany.co.uk]]></programlisting>
                <para>Notice how the child <classname>Properties</classname> collection's
                value set will have inherited all the property elements from the parent
                <literal>&lt;props/&gt;</literal>. Notice also how the child's value for
                the <literal>support</literal> value overrides the attendant value in the
                parent collection.</para>
                <para>This merging behavior applies similarly to the <literal>list</literal>,
                <literal>map</literal>, and <literal>set</literal> collection types. In
                the specific case of the <literal>list</literal> element, the semantics
                associated with the <classname>List</classname> collection type, i.e. the
                notion of an <literal>ordered</literal> collection of values, is maintained;
                the  parent's values will precede all of the child list's values. In the
                case of the <literal>map</literal>, <literal>set</literal>, and
                <literal>props</literal> collection types, there is no notion of ordering
                and hence no ordering semantics are in effect for the collection types that
                underlie the associated <classname>Map</classname>, <classname>Set</classname>
                and <classname>Properties</classname> implementation types used internally
                by the container.</para>
                <para>Finally, some minor notes about the merging support are in order; one
                cannot merge different collection types (e.g. a <literal>map</literal> and
                a <literal>list</literal>), and if one does attempt to do so an appropriate
                <classname>Exception</classname> will be thrown; and in case it is not
                immediately obvious, the <literal>'merge'</literal> attribute must be specified
                on the lower level, inherited, child definition; specifying the
                <literal>'merge'</literal> attribute on a parent collection definition is
                redundant and will not result in the desired merging; and (lastly), please
                note that this merging feature is only available in Spring 2.0 (and later
                versions).</para>
            </section>
            <section>
                <title>Strongly-typed collection (Java5+ only)</title>
                <para>If you are one of the lucky few to be using Java5 (Tiger), you will be aware
                that it is possible (and I daresay recommended) to have strongly typed collections.
                That is, it is possible to declare a <interfacename>Collection</interfacename> type
                such that it can only contain <classname>String</classname> elements (for example).</para>
                <para>If you are using Spring to dependency inject a strongly-typed
                <interfacename>Collection</interfacename> into a bean, you can take advantage
                of Spring's type-conversion support such that the elements of your strongly-typed
                <interfacename>Collection</interfacename> instances will be converted to the
                appropriate type prior to being added to the <interfacename>Collection</interfacename>.</para>
                <para>An example will make this clear; consider the following class definition, and
                it's attendant (XML) configuration...</para>
                <programlisting><![CDATA[public class Foo {
                
    private Map<String, Float> accounts;
    
    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }

}]]></programlisting>
                <programlisting><![CDATA[<beans>
    
    <bean id="foo" class="x.y.Foo">
        
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>

    </bean>

</beans>]]></programlisting>
                <para>When the <literal>'accounts'</literal> property of the <literal>'foo'</literal>
                bean is being prepared for injection, the generics information about the element
                type of the strongly-typed <classname>Map&lt;String, Float&gt;</classname> is
                actually available via reflection, and so Spring's type conversion infrastructure
                will actually recognize the various value elements as being of type <classname>Float</classname>
                and so the string values <literal>'9.99', '2.75'</literal>, and <literal>'3.99'</literal>
                will be converted into an actual <classname>Float</classname> type.</para>
            </section>
            </section>
            <section id="beans-null-element">
                <title><literal>Nulls</literal></title>
                <para>The <literal>&lt;null/&gt;</literal> element is used to handle
                <literal>null</literal> values. Spring treats empty arguments for
                properties and the like as empty <literal>Strings</literal>. The following
                XML-based configuration metadata snippet  results in the email property
                being set to the empty <classname>String</classname> value ("")</para>
        <programlisting><![CDATA[<bean class="ExampleBean">
  <property name="email"><value></value></property>
</bean>]]></programlisting>
                <para>This is equivalent to the following Java code:
                <literal>exampleBean.setEmail("")</literal>. The special
                <literal>&lt;null&gt;</literal> element may be used to indicate a
                <literal>null</literal> value. For example:</para>
                <programlisting><![CDATA[<bean class="ExampleBean">
  <property name="email"><null/></property>
</bean>]]></programlisting>
                <para>The above configuration is equivalent to the following Java code:
                <literal>exampleBean.setEmail(null)</literal>. </para>
            </section>
            <section>
                <title id="beans-value-ref-shortcuts">XML-based configuration metadata shortcuts</title>
                <para>It is so common to need to configure a value or a bean
                reference, that there exist some shortcut forms which are less verbose
                than using the full <literal>&lt;value/&gt;</literal> and
                <literal>&lt;ref/&gt;</literal> elements. The <literal>&lt;property/&gt;</literal>,
                <literal>&lt;constructor-arg/&gt;</literal>, and <literal>&lt;entry/&gt;</literal>
                elements all support a <literal>'value'</literal> attribute which may be
                used instead of embedding a full <literal>&lt;value/&gt;</literal> element.
                Therefore, the following:</para>
                <programlisting><![CDATA[<property name="myProperty">
  <value>hello</value>
</property>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg>
  <value>hello</value>
</constructor-arg>]]></programlisting>
                <programlisting><![CDATA[<entry key="myKey">
  <value>hello</value>
</entry>]]></programlisting>
                <para>are equivalent to:</para>
                <programlisting><![CDATA[<property name="myProperty" value="hello"/>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg value="hello"/>]]></programlisting>
                <programlisting><![CDATA[<entry key="myKey" value="hello"/>]]></programlisting>
                <para>In general, when typing definitions by hand, you will probably prefer to
                use the less verbose shortcut form (the Spring team certainly do).</para>
                <para>The <literal>&lt;property/&gt;</literal> and
                <literal>&lt;constructor-arg/&gt;</literal> elements support a similar
                shortcut <literal>'ref'</literal> attribute which may be used instead
                of a full nested <literal>&lt;ref/&gt;</literal> element. Therefore,
                the following:</para>
                <programlisting><![CDATA[<property name="myProperty">
  <ref bean="myBean">
</property>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg>
  <ref bean="myBean">
</constructor-arg>]]></programlisting>
                <para>are equivalent to:</para>
                <programlisting><![CDATA[<property name="myProperty" ref="myBean"/>]]></programlisting>
                <programlisting><![CDATA[<constructor-arg ref="myBean"/>]]></programlisting>
                <para>Note however that the shortcut form is equivalent to a
                <literal>&lt;ref bean="xxx"&gt;</literal> element; there is no
                shortcut for <literal>&lt;ref local="xxx"</literal>&gt;. To enforce a
                strict local reference, you must use the long form.</para>
                <para>Finally, the entry element allows a shortcut form to specify the
                key and/or value of the map, in the form of the <literal>'key'</literal>
                / <literal>'key-ref'</literal> and <literal>'value'</literal> /
                <literal>'value-ref'</literal> attributes. Therefore, the following:</para>
                <programlisting><![CDATA[<entry>
  <key>
    <ref bean="myKeyBean" />
  </key>
  <ref bean="myValueBean" />
</entry>]]></programlisting>
                <para>is equivalent to:</para>
                <programlisting><![CDATA[<entry key-ref="myKeyBean" value-ref="myValueBean"/>]]></programlisting>
                <para>Again, the shortcut form is equivalent to a
                <literal>&lt;ref bean="xxx"&gt;</literal> element; there is no shortcut for
                <literal>&lt;ref local="xxx"</literal>&gt;.</para>
            </section>
            <section>
                <title id="beans-compound-property-names">Compound property names</title>
                <para>Compound or nested property names are perfectly legal
                when setting bean properties, as long as all components of the path
                except the final property name are non-null. For example, in this bean
                definition:</para>
                <programlisting><![CDATA[<bean id="foo" class="foo.Bar">
  <property name="fred.bob.sammy" value="123" />
</bean>]]></programlisting>
                <para>The <literal>foo</literal> bean has a <literal>fred</literal> property which has a
                <literal>bob</literal> property, which has a <literal>sammy</literal>
                property, and that final <literal>sammy</literal> property is being
                set to a scalar value of 123. In order for this to work, the
                <literal>fred</literal> property of <literal>foo</literal>, and the
                <literal>bob</literal> property of <literal>fred</literal> must both
                be non-null after the bean is constructed, or a
                <classname>NullPointerException</classname> will be thrown.</para>
            </section>
        </section>
        <section id="beans-factory-method-injection">
            <title>Method Injection</title>
            <para>For most users, the majority of the beans in the container will be
            singletons. When a singleton bean needs to collaborate with (use)
            another singleton bean, or a non-singleton bean needs to collaborate
            with another non-singleton bean, the typical and common approach of
            handling this dependency by defining one bean to be a property of the
            other, is quite adequate. There is however a problem when the bean
            lifecycles are different. Consider a singleton bean A which needs to use
            a non-singleton (prototype) bean B, perhaps on each method invocation on
            A. The container will only create the singleton bean A once, and thus
            only get the opportunity to set its properties once. There is no
            opportunity for the container to provide bean A with a new instance of
            bean B every time one is needed.</para>
            <para>One solution to this problem is to forgo some inversion of
            control. Bean A can be aware of the container (as described <link linkend="beans-factory-aware-beanfactoryaware">here</link>) by
            implementing <literal>BeanFactoryAware</literal>, and use programmatic
            means (as described <link linkend="beans-factory-client">here</link>) to
            ask the container via a <literal>getBean("B")</literal> call for (a new)
            bean B every time it needs it. This is generally not a desirable
            solution since the bean code is then aware of and coupled to
            Spring.</para>
            <para>Method Injection, an advanced feature of the Spring IoC container, allows
            this use case to be handled in a clean fashion, along with some other
            scenarios.</para>
            <section>
                <title>Lookup method injection</title>
                <para>Lookup method injection refers to the ability of the container
                to override abstract or concrete methods on managed beans in the
                container, to return the result of looking up another named bean in
                the container. The lookup will typically be of a non-singleton bean as
                per the scenario described above (although it can also be a
                singleton). Spring implements this through a dynamically generated
                subclass overriding the method, using bytecode generation via the
                CGLIB library.</para>
                <para>In the client class containing the method to be injected, the
                method definition must be an abstract (or concrete) definition in this
                form:</para>
                <programlisting><![CDATA[protected abstract SingleShotHelper createSingleShotHelper();]]></programlisting>
                <para>If the method is not abstract, Spring will simply override the
                existing implementation. In the case of XML-based cnfiguration metadata,
                you instruct Spring to inject/override this method to return a particular
                bean from the container, by using the <literal>lookup-method</literal>
                element inside the bean definition. For example:</para>
                <programlisting><lineannotation>&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</lineannotation><![CDATA[
<bean id="singleShotHelper" class="..." singleton="false"/>

]]><lineannotation>&lt;!-- myBean uses singleShotHelper --&gt;</lineannotation><![CDATA[
<bean id="myBean" class="...">
  <lookup-method name="createSingleShotHelper" bean="singleShotHelper"/>
  <property>
    ...
  </property>
</bean>]]></programlisting>
                <para>The bean identified as <emphasis>myBean</emphasis> will call its
                own method <literal>createSingleShotHelper</literal> whenever it needs
                a new instance of the <emphasis>singleShotHelper</emphasis> bean. It
                is important to note that the person deploying the beans must be
                careful to deploy <emphasis>singleShotHelper</emphasis> as a
                non-singleton (if that is actually what is needed). If it is deployed
                as a singleton (either explicitly, or relying on the default
                <emphasis>true</emphasis> setting for this flag), the same instance of
                singleShotHelper will be returned each time!</para>
                <para>Note that lookup method injection can be combined with
                Constructor Injection (supplying optional constructor arguments to the
                bean being constructed), and also with Setter Injection (settings
                properties on the bean being constructed).</para>
            </section>
            <section>
                <title>Arbitrary method replacement</title>
                <para>A less commonly useful form of method injection than Lookup
                Method Injection is the ability to replace arbitrary methods in a
                managed bean with another method implementation. Users may safely skip
                the rest of this section (which describes this somewhat advanced
                feature), until this functionality is actually needed.</para>
                <para>When using XML-based configuration metadata, the <literal>replaced-method</literal>
                element may be used to replace an existing method implementation with
                another, for a deployed bean. Consider the following class, with a
                method computeValue, which we want to override:</para>
        
                <programlisting><![CDATA[public class MyValueCalculator {

  public String computeValue(String input) {
    ]]><lineannotation>// some real code...</lineannotation><![CDATA[
  }

  ]]><lineannotation>// some other methods...</lineannotation><![CDATA[

}]]></programlisting>
                <para>A class implementing the
                <interfacename>org.springframework.beans.factory.support.MethodReplacer</interfacename>
                interface provides the new method definition.</para>
                
                <programlisting><![CDATA[/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}]]></programlisting>
                <para>The bean definition to deploy the original class and specify the
                method override would look like this:</para>
                <programlisting><![CDATA[<bean id="myValueCalculator class="x.y.z.MyValueCalculator">
  ]]><lineannotation>&lt;!-- arbitrary method replacement --&gt;</lineannotation><![CDATA[
  <replaced-method name="computeValue" replacer="replacementComputeValue">
    <arg-type>String</arg-type>
  </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>]]></programlisting>
                <para>One or more contained <literal>&lt;arg-type/&gt;</literal> elements
                within the <literal>&lt;replaced-method/&gt;</literal> element may be used to
                indicate the method signature of the method being overridden. Note
                that the signature for the arguments is actually only needed in the
                case that the method is actually overloaded and there are multiple
                variants within the class. For convenience, the type string for an
                argument may be a substring of the fully qualified type name. For
                example, all the following would match <classname>java.lang.String</classname>.</para>
                <programlisting><![CDATA[    java.lang.String
    String
    Str]]></programlisting>
                <para>Since the number of arguments is often enough to
                distinguish between each possible choice, this shortcut can save a lot
                of typing, by just using the shortest string which will match an
                argument.</para>
            </section>
        </section>
        <section id="beans-factory-dependson">
            <title>Using <literal>depends-on</literal></title>
            <para>For most situations, the fact that a bean is a dependency of another is 
            expressed simply by the fact that one bean is set as a property of another.
            This is typically accomplished with the <literal>&lt;ref/&gt;</literal> element
            in XML-based configuration metadata. In a variation of this, sometimes a bean
            which is aware of the container is simply given the id of its dependency (using
            a string value or alternately the <literal>&lt;idref/&gt;</literal> element,
            which evaluates the same as a string value). The first bean then programmatically
            asks the container for its dependency. In either case, the dependency is properly
            initialized before the dependent bean.</para>
            <para>For the relatively infrequent situations where dependencies
			between beans are less direct (for example, when a static initializer in
			a class needs to be triggered, such as database driver registration),
			the <literal>'depends-on'</literal> attribute may be used to explicitly
			force one or more beans to be initialized before the bean using this
			element is initialized. Find below an example of using the
			<literal>'depends-on'</literal> attribute to express a dependency on a single bean.</para>
            <programlisting><![CDATA[<bean id="beanOne" class="ExampleBean" depends-on="manager">
  <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />]]></programlisting>
            <para>If you need to express a dependency on multiple beans, you can supply a
            delimited list of beans names as the value of the <literal>&lt;depends-on/&gt;</literal>
            attribute, with commas, whitespace and semi-colons all valid delimiters. Find
            below an example of using <literal>'depends-on'</literal> to express a dependency
            on a number of beans.</para>
            <programlisting><![CDATA[<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
  <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />]]></programlisting>
        </section>
        <section id="beans-factory-lazy-init">
            <title>Lazily-instantiating beans</title>
            <para>The default behavior for <interfacename>ApplicationContext</interfacename>
            implementations is to eagerly pre-instantiate all <literal>singleton</literal> beans
            at startup. Pre-instantiation means that an <interfacename>ApplicationContext</interfacename>
            implementation instance will eagerly create and configure all of it's singleton beans
            as part of its initialization process. This is generally <emphasis>a good thing</emphasis>,
            because it means that any errors in the configuration or in the attendant environment
            will be discovered immediately (as opposed to possibly hours or even days down the line).</para>
            <para>However, there are times when this behavior is <emphasis>not</emphasis> what is wanted.
            If you do not want a singleton bean to be pre-instantiated when using
            an <interfacename>ApplicationContext</interfacename> implementation, you can (on
            a bean-definition by bean-definition basis) selectively control this by marking a
            bean definition as lazy-initialized. A lazily-initialized bean indicates to the
            IoC container whether or not a bean instance should be created at startup or when it
            is first requested.</para>
            <para>When one is configuring beans via XML, this lazy loading is controlled by the
            <literal>'lazy-init'</literal> attribute on the <literal>&lt;bean/&gt;</literal>
            element; to wit...</para>
            <programlisting><![CDATA[<bean id="lazy" class="com.foo.ExpensiveToCreateBean" ]]><emphasis role="bold">lazy-init="true"</emphasis><![CDATA[>
    ]]><lineannotation>&lt;!-- various properties here... --&gt;</lineannotation><![CDATA[
</bean>

<bean name="not.lazy" class="com.foo.AnotherBean">
    ]]><lineannotation>&lt;!-- various properties here... --&gt;</lineannotation><![CDATA[
</bean>]]></programlisting>
            <para>When the above configuration is consumed by an
            <interfacename>ApplicationContext</interfacename> implementation, the bean named
            <literal>'lazy'</literal> will <emphasis>not</emphasis> be eagerly pre-instantiated
            when the <interfacename>ApplicationContext</interfacename> is starting up, whereas
            the <literal>'not.lazy'</literal> bean will be eagerly pre-instantiated.</para>
            <para>One thing to understand about lazy-initialization is that even though a bean
            definition may be marked up as being lazy-initialized, if the lazy-initialized bean
            is the dependency of a singleton bean that is not lazy-initialized, when the
            <interfacename>ApplicationContext</interfacename> is eagerly pre-instantiating the
            singleton, it will (of course) have to satisfy all of said singletons dependencies,
            one of which will be the lazy-initialized bean! So don't be confused if the IoC
            container creates one of the beans that you have explicitly configured as
            lazy-initialized at startup; all that means is that the lazy-initialized bean
            probably is being injected into a non-lazy-initialized singleton bean elsewhere
            in your configuration.</para>
            <para>It is also possible to control lazy-initialization at the container level by using
            the <literal>'default-lazy-init'</literal> attribute on the <literal>&lt;beans/&gt;</literal>
            element; to wit:</para>
            <programlisting><![CDATA[<beans default-lazy-init="true">
    ]]><lineannotation>&lt;!-- no beans will be eagerly pre-instantiated... --&gt;</lineannotation><![CDATA[
</beans>]]></programlisting>
        </section>
        <section id="beans-factory-autowire">
            <title>Autowiring collaborators</title>
            <para>A Spring IoC container is able to <emphasis>autowire</emphasis>
            relationships between collaborating beans. This means that it is possible to
            automatically let Spring resolve collaborators (other beans) for your
            bean by inspecting the contents of the <interfacename>BeanFactory</interfacename>.
            The autowiring functionality has five modes. Autowiring is specified
            <emphasis>per</emphasis> bean and can thus be enabled for some beans,
            while other beans won't be autowired. Using autowiring, it is possible
            to reduce or eliminate the need to specify properties or constructor
            arguments, saving a significant amount of typing.
            <footnote><para>See the section entitled <xref linkend="beans-factory-collaborators" /></para></footnote>
            When using XML-based configuration metadata, the autowire mode for a bean definition
            is specified by using the <literal>autowire</literal> attribute of the
            <literal>&lt;bean/&gt;</literal> element. The following values are allowed:</para>
            <table>
                <title>Autowiring modes</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="1*" />
                    <colspec colname="c2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Mode</entry>
                            <entry>Explanation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>no</entry>
                            <entry>
                                <para>No autowiring at all. Bean references must be defined
                                via a <literal>ref</literal> element. This is the default, and
                                changing this is discouraged for larger deployments, since
                                explicitly specifying collaborators gives greater control and
                                clarity. To some extent, it is a form of documentation about
                                the structure of a system.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>byName</entry>
                            <entry>
                                <para>Autowiring by property name. This option will inspect
                                the container and look for a bean named exactly the same as
                                the property which needs to be autowired. For example, if you
                                have a bean definition which is set to autowire by name, and
                                it contains a <emphasis>master</emphasis> property (that is,
                                it has a <emphasis>setMaster(..)</emphasis> method), Spring
                                will look for a bean definition named <literal>master</literal>,
                                and use it to set the property.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>byType</entry>
                            <entry>
                                <para>Allows a property to be autowired if there is exactly
                                one bean of the property type in the container. If there is
                                more than one, a fatal exception is thrown, and this indicates
                                that you may not use <emphasis>byType</emphasis> autowiring
                                for that bean. If there are no matching beans, nothing
                                happens; the property is not set. If this is not desirable,
                                setting the <literal>dependency-check="objects"</literal>
                                attribute value specifies that an error should be thrown in
                                this case.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>constructor</entry>
                            <entry>
                                <para>This is analogous to <emphasis>byType</emphasis>, but
                                applies to constructor arguments. If there isn't exactly one
                                bean of the constructor argument type in the container, a
                                fatal error is raised.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>autodetect</entry>
                            <entry>
                                <para>Chooses <emphasis>constructor</emphasis> or
                                <emphasis>byType</emphasis> through introspection of the bean
                                class. If a default constructor is found, the
                                <emphasis>byType</emphasis> mode will be applied.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>Note that explicit dependencies in <literal>property</literal> and
            <literal>constructor-arg</literal> settings <interfacename>always</interfacename>
            override autowiring. Please also note that it is not currently possible to autowire
            so-called <emphasis>simple</emphasis> properties such as primitives,
            <classname>Strings</classname>, and <classname>Classes</classname> (and arrays of such
            simple properties).(This is by-design and should be considered a <emphasis>feature</emphasis>.)
            Autowire behavior can be combined with dependency checking, which will
            be performed after all autowiring has been completed.</para>
            <para>It is important to understand the various advantages and disadvantages of autowiring.
            Some advantages of autowiring include:</para>
            <itemizedlist>
                <listitem>
                    <para>Autowiring can significantly reduce the volume of configuration
                    required. However, mechanisms such as the use of a bean template
                    (<link linkend="beans-child-bean-definitions">discussed elsewhere in this chapter</link>)
                    are also valuable in this regard.</para>
                </listitem>
                <listitem>
                    <para>Autowiring can cause configuration to keep itself up to date
                    as your objects evolve. For example, if you need to add an additional
                    dependency to a class, that dependency can be satisfied
                    automatically without the need to modify configuration. Thus there
                    may be a strong case for autowiring during development, without
                    ruling out the option of switching to explicit wiring when the code
                    base becomes more stable.</para>
                </listitem>
            </itemizedlist>
            <para>Some disadvantages of autowiring:</para>
            <itemizedlist>
                <listitem>
                    <para>Autowiring is more magical than explicit wiring. Although,
                    as noted in the above table, Spring is careful to avoid guessing
                    in case of ambiguity which might have unexpected results, the
                    relationships between your Spring-managed objects is no longer
                    explicitly documented.</para>
                </listitem>
                <listitem>
                    <para>Wiring information may not be available to tools that may
                    generate documentation from a Spring container.</para>
                </listitem>
                <listitem>
                    <para>Autowiring by type will only work when there is a single bean
                    definition of the type specified by the setter method or constructor
                    argument. You need to use explicit wiring if there is any potential
                    ambiguity.</para>
                </listitem>
            </itemizedlist>
            <para>There is no "wrong" or "right" answer in all cases. A degree of
            consistency across a project is best though; for example, if autowiring is
            not used in general, it might be confusing to developers to use it just
            to wire one or two bean definitions.</para>
            <section id="beans-factory-autowire-candidate">
                <title>Excluding a bean from being available for autowiring</title>
                <para>One can also (on a per bean basis) totally exclude a bean from being an
                autowire candidate. When configuring beans using Spring's XML format, the
                <literal>'autowire-candidate'</literal> attribute of the
                <literal>&lt;bean/&gt;</literal> element can be set to
                <literal>'false'</literal>; this has the effect of making the container
                totally exclude that specific bean definition from being available
                to the autowiring infrastructure.</para>
                <para>This can be useful when one has a bean that one absolutely never ever
                wants to have injected into other beans via autowiring. It does not
                mean that the excluded bean cannot itself be configured using autowiring...
                it can, it is rather that it itself will not be considered as a candidate
                for autowiring other beans.</para>
            </section>
        </section>
        <section id="beans-factory-dependencies">
            <title>Checking for dependencies</title>
            <para>The Spring IoC container also has the ability to try to check for the
			existence of unresolved dependencies of a bean deployed into the container.
			These are JavaBeans properties of the bean, which do not have actual values
			set for them in the bean definition, or alternately provided
			automatically by the autowiring feature.</para>
            <para>This feature is sometimes useful when you want to ensure that all
			properties (or all properties of a certain type) are set on a bean. Of
			course, in many cases a bean class will have default values for many
			properties, or some properties do not apply to all usage scenarios, so
			this feature is of limited use. Dependency checking can also be enabled
			and disabled per bean, just as with the autowiring functionality. The
			default is to <emphasis>not</emphasis> check dependencies. Dependency
			checking can be handled in several different modes. When using
			XML-based configuration metadata, this is specified via the
			<literal>'dependency-check'</literal> attribute in a bean definition,
			which may have the following values.</para>
			<table frame="all">
                <title>Dependency checking modes</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="1*" />
                    <colspec colname="c2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Mode</entry>
                            <entry>Explanation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>none</entry>
                            <entry>
                                <para>No dependency checking. Properties of the bean which
                                have no value specified for them are simply not set.</para>
                            </entry>
                        </row>
                        <row>
                            <entry>simple</entry>
                            <entry>
                                <para>Dependency checking is performed for primitive types
                                and collections (everything except collaborators, i.e. other
                                beans)</para>
                            </entry>
                        </row>
                        <row>
                            <entry>object</entry>
                            <entry>
                                <para>Dependency checking is performed for collaborators only</para>
                            </entry>
                        </row>
                        <row>
                            <entry>all</entry>
                            <entry>
                                <para>Dependency checking is done for collaborators, primitive types
                                and collections</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>If you are using Java 5 (Tiger) and thus have access to source level annotations,
			you may find the section entitled <xref linkend="metadata-annotations-required"/>
			to be of interest.</para>
        </section>
    </section>
    <section id="beans-factory-scopes">
        <title>Bean scopes</title>
        <para>When you create a bean definition (typically via an XML configuration file)
        what you are actually creating is (loosely speaking) a <emphasis>recipe</emphasis>
        or template for creating actual instances of the objects defined by that
        bean definition. The fact that a bean definition is a recipe is important,
        because it means that, just like a class, you can potentially have many object
        instances created off the back of a single recipe.</para>
        <para>You can control not only the various dependencies and
        configuration values that are to be plugged into an object that is created
        from a particular bean definition, but also the <firstterm>scope</firstterm>
        of the objects created from a particular bean definition. This approach is very
        powerful and gives you the flexibility to <emphasis>choose</emphasis> the scope
        of the objects you create, and not have to 'bake in' such scope at the Java
        class level. Beans can be defined to be deployed in one of a number of scopes:
        out of the box, the Spring Framework supports exactly five scopes (although
        three of those scopes are only available if you are using a web-aware Spring
        <interfacename>ApplicationContext</interfacename>).</para>
		<para>The scopes supported out of the box are listed below:</para>
		<table>
			<title>Bean scopes</title>
			<tgroup cols="2">
				<thead>
					<row>
						<entry align="center">Scope</entry>
						<entry align="center">Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>
							<para><link linkend="beans-factory-scopes-singleton">singleton</link></para>
						</entry>
						<entry>
							<para>Scopes a single bean definition to a single object instance per Spring IoC container.</para>
						</entry>
					</row>
					<row>
						<entry>
							<para><link linkend="beans-factory-scopes-prototype">prototype</link></para>
						</entry>
						<entry>
							<para>Scopes a single bean definition to any number of object instances.</para>
						</entry>
					</row>
					<row>
						<entry>
							<para><link linkend="beans-factory-scopes-request">request</link></para>
						</entry>
						<entry>
							<para>Scopes a single bean definition to the lifecycle of
							a single HTTP request; i.e. each and every HTTP request will
							have it's own instance of a bean created off the back of a
							single bean definition. Only valid in the context of a
							web-aware Spring <interfacename>ApplicationContext</interfacename>.</para>
						</entry>
					</row>
					<row>
						<entry>
							<para><link linkend="beans-factory-scopes-global-session">session</link></para>
						</entry>
						<entry>
							<para>Scopes a single bean definition to the lifecycle of
							a HTTP <interfacename>Session</interfacename>. Only valid in
							the context of a web-aware Spring
							<interfacename>ApplicationContext</interfacename>.</para>
						</entry>
					</row>
					<row>
						<entry>
							<para><link linkend="beans-factory-scopes-global-session">global session</link></para>
						</entry>
						<entry>
							<para>Scopes a single bean definition to the lifecycle of a
							global HTTP <interfacename>Session</interfacename>. Typically
							only valid when used in a portlet context. Only valid in the
							context of a web-aware Spring
							<interfacename>ApplicationContext</interfacename>.</para>
						</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

        <note>
            <para>For backwards compatibility reasons it is still possible to specify
            <literal>singleton="false"</literal> and <literal>singleton="true"</literal>
            as arguments to a bean definition. However, note that specifying both the
            <literal>singleton</literal> and <literal>scope</literal> argument on a bean
            definition leads to unexpected behaviour. You should only specify one of the
            two options, where the use of <literal>scope</literal> is the prefered choice.
            </para>
		</note>

        <section id="beans-factory-scopes-singleton">
		    <title>The singleton scope</title>
		    <para>When a bean is a singleton, only one <emphasis>shared</emphasis>
		    instance of the bean will be managed and all requests for beans with
		    an id or ids matching that bean definition will result in that one
		    specific bean instance being returned.</para>
		    <para>To put it another way, when you define a bean definition and it
		    is scoped as a singleton, then the Spring IoC container will create
		    <emphasis>exactly one</emphasis> instance of the object defined by
		    that bean definition (or recipe). This single instance will be 
		    stored in a singleton cache, and <emphasis>all subsequent requests
		    and references</emphasis> for that named bean will result in the cached
		    object instance being returned.</para>
		    <para>The following diagram illustrates the Spring singleton scope.</para>
		    <para>
			    <mediaobject>
				    <imageobject role="fo">
					    <imagedata fileref="images/singleton.png" format="PNG" align="center" />
				    </imageobject>
				    <imageobject role="html">
					    <imagedata fileref="images/singleton.png" format="PNG" align="center" />
				    </imageobject>
			    </mediaobject>
		    </para>
			<para>Please be aware that Spring's concept of a singleton bean is quite
			different from the Singleton pattern as defined in the seminal Gang of
			Four (GoF) patterns book. The classic GoF Singleton hardcodes the scope of
			an object such that one <emphasis>and only one</emphasis> instance of a
			particular class will ever be created<emphasis> per
			<classname>ClassLoader</classname></emphasis>.</para>
			<para>The scope of the Spring singleton is best described as
			<emphasis>per <interfacename>container</interfacename> and per bean</emphasis>.
			This means that if you define one bean for a particular class in a single
			Spring container, then the Spring container will create one
			<emphasis>and only one</emphasis> instance of the class defined by that
			bean definition. This also means that you can define more than one bean
			definition for a single class, and then Spring will create exactly two
			instances of that particular class, each with their own particular
			configuration.</para>
		    <para><emphasis>The singleton scope is the default scope in Spring</emphasis>.
		    To define a bean as a singleton in XML, you would write configuration like so:</para>
		    <programlisting><![CDATA[<bean id="accountService" class="com.foo.DefaultAccountService"/>

]]><lineannotation>&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</lineannotation><![CDATA[
<bean id="accountService" class="com.foo.DefaultAccountService" scope="singleton"/>

]]><lineannotation>&lt;!-- the following is equivalent, though redundant (and preserved for backward compatibility) --&gt;</lineannotation><![CDATA[
<bean id="accountService" class="com.foo.DefaultAccountService" singleton="true"/>]]></programlisting>
		</section>

		<section id="beans-factory-scopes-prototype">
		    <title>The prototype scope</title>
		    <para>The non-singleton, prototype scope of bean deployment results in
			the <emphasis>creation of a new bean instance</emphasis> every time a
			request for that specific bean is made (that is, it is injected into another
			bean or it is requested via a programmatic <literal>getBean()</literal>
			method call on the container). As a rule of thumb, you should
            use the prototype scope for all beans that are stateful, while the
            singleton scope should be used for stateless beans.</para>
		    <para>The following diagram illustrates the Spring prototype scope.
		    <emphasis>Please note that a DAO would not typically be configured as a
		    prototype, since a typical DAO would not hold any conversational state;
		    it was just easier for this author to reuse the core of the singleton
		    diagram.</emphasis></para>
		    <para>
			    <mediaobject>
				    <imageobject role="fo">
					    <imagedata fileref="images/prototype.png" format="PNG" align="center" />
				    </imageobject>
				    <imageobject role="html">
					    <imagedata fileref="images/prototype.png" format="PNG" align="center" />
				    </imageobject>
			    </mediaobject>
		    </para>
		    <para>To define a bean as a prototype in XML, you would write configuration like so:</para>
		    <programlisting><![CDATA[<bean id="accountService" class="com.foo.DefaultAccountService" scope="prototype"/>

]]><lineannotation>&lt;!-- the following is equivalent too (and preserved for backward compatibility) --&gt;</lineannotation><![CDATA[
<bean id="accountService" class="com.foo.DefaultAccountService" singleton="false"/>]]></programlisting>
			<para>There is one quite important thing to be aware of when deploying a bean
			in the prototype scope, in that the lifecycle of the bean changes slightly.
			Spring cannot (and hence does not) manage the complete lifecycle of a prototype
			bean: the container instantiates, configures, decorates and otherwise assembles a
			prototype object, hands it to the client and then has no further knowledge of that
			prototype instance. This means that while initialization lifecycle callback
			methods will be (and are) called on all objects regardless of scope, in the case
			of prototypes any configured destruction lifecycle callbacks will <emphasis>not</emphasis>
			be called. It is the responsibility of the client code to clean up
			prototype scoped objects and release any expensive resources that the prototype
			bean(s) are holding onto. (one possible way to do this would be via the use
			of a bean post processor which would hold onto beans which need to be cleaned
			up)</para>
			<para>You can in some respects think of the Spring containers role when talking
			about a prototype-scoped bean as somewhat of a replacement for the Java
			<literal>'new'</literal> operator. Any lifecycle aspects past that point have to
			be handled by the client. The lifecycle of a bean in a Spring IoC container is
			further described in the section entitled
			<xref linkend="beans-factory-lifecycle" />.</para>
		</section>

		<section id="beans-factory-scopes-other">
			<title>The other scopes</title>
			<para>The other scopes, namely <literal>request</literal>, <literal>session</literal>,
			and <literal>global session</literal> are for use only in web-based applications
			(and can be used irrespective of which particular web application framework you are
			using, if indeed any). In the interest of keeping related concepts together in
			one place in the reference documentation, these scopes are described here.</para>
			<note>
			    <para>The scopes that are described in the following paragraphs are
			    <emphasis>only</emphasis> available if you are using a web-aware
			    Spring <interfacename>ApplicationContext</interfacename> implementation
			    (such as <classname>XmlWebApplicationContext</classname>).
			    If you try using these next scopes with regular Spring IoC containers such as
			    the <classname>XmlBeanFactory</classname> or
			    <classname>ClassPathXmlApplicationContext</classname>, you <emphasis>will</emphasis>
			    get an <classname>IllegalStateException</classname> complaining about
			    an unknown bean scope.</para>
			</note>

			<section id="beans-factory-scopes-other-web-configuration">
			    <title>Initial web configuration</title>
                <para>In order to effect the scoping of beans at the <literal>request</literal>,
                <literal>session</literal>, and <literal>global session</literal> level
                (i.e. web-scoped beans), some initial (small) configuration is required
                before you can set about defining your bean definitions. Please note that
                this extra setup is <emphasis>not</emphasis> required if you just want the
                'normal' (for want of a better word) scopes; i.e. singleton and prototype.</para>
                <para>Now as things stand, there are a couple of ways to effect this
                initial setup depending on your particular servlet environment. If you are
                using a Servlet 2.4+ web container, then you need only add the following
                <interfacename>ContextListener</interfacename> to the XML declarations in
                your web applications <literal>'web.xml'</literal> file.</para>
                <programlisting><![CDATA[<web-app>
  ...
  <listener>
    <listener-class>org.springframework.web.context.scope.RequestContextListener</listener-class>
  </listener>
  ...
</web-app>]]></programlisting>
                <para>If you are using an older web container (before Servlet 2.4), you will need to use
                a (provided) <interfacename>javax.servlet.Filter</interfacename> implementation.
                Find below a snippet of XML configuration that has to be included
                in the <literal>'web.xml'</literal> file of your web application if you
                want to have access to web-scoped beans (the filter settings depend on
                the surrounding web application configuration and so you will have to change
                them as appropriate).</para>
                <programlisting><![CDATA[<web-app>
  ..
  <filter> 
    <filter-name>requestContextFilter</filter-name> 
    <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
  </filter> 
  <filter-mapping> 
    <filter-name>requestContextFilter</filter-name> 
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  ...
</web-app>]]></programlisting>
                <para>That's it. The <classname>RequestContextListener</classname> and
                <classname>RequestContextFilter</classname> classes both do exactly the
                same thing, namely bind the HTTP request object to the
                <classname>Thread</classname> that is servicing that request. This makes
                beans that are request- and session-scoped available further down the
                call chain.</para>
			</section>

			<section id="beans-factory-scopes-request">
			    <title>The request scope</title>
                <para>Consider the following bean definition:</para>
                <programlisting><![CDATA[<bean id="loginAction" class="com.foo.LoginAction" scope="request"/>]]></programlisting>
                <para>With the above bean definition in place, the Spring container will create
                a brand new instance of the <classname>LoginAction</classname> bean
                using the <literal>'loginAction'</literal> bean definition for each and
                every HTTP request. That is, the <literal>'loginAction'</literal> bean will be
                effectively scoped at the HTTP request level. You can change or dirty
                the internal state of the instance that is created as much as you want,
                safe in the knowledge that other requests that are also using instances created
                off the back of the same <literal>'loginAction'</literal> bean definition
                will not be seeing these changes in state particular to an individual
                request. When the request is finished processing, the bean that is scoped
                to the request will be discarded.</para>
			</section>

			<section id="beans-factory-scopes-session">
			    <title>The session scope</title>
                <para>Consider the following bean definition:</para>
                <programlisting><![CDATA[<bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/>]]></programlisting>
                <para>With the above bean definition in place, the Spring container will create
                a brand new instance of the <classname>UserPreferences</classname> bean
                using the <literal>'userPreferences'</literal> bean definition for the
                lifetime of a single HTTP <interfacename>Session</interfacename>.
                In other words, the <literal>'userPreferences'</literal> bean will be
                effectively scoped at the HTTP <interfacename>Session</interfacename> level.
                Just like <literal>request-scoped</literal> beans you can change the internal
                state of the instance that is created as much as you want, safe in the
                knowledge that other HTTP <interfacename>Session</interfacename> instances
                that are also using instances created off the back of the same
                <literal>'userPreferences'</literal> bean definition
                will not be seeing these changes in state particular to an individual
                HTTP <interfacename>Session</interfacename>. When the HTTP
                <interfacename>Session</interfacename> is eventually discarded, the bean
                that is scoped to that particular HTTP <interfacename>Session</interfacename>
                will also be discarded.</para>
			</section>

			<section id="beans-factory-scopes-global-session">
			    <title>The global session scope</title>
                <para>Consider the following bean definition:</para>
                <programlisting><![CDATA[<bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/>]]></programlisting>
                <para>The <literal>global session</literal> scope is similar to the
                standard HTTP <interfacename>Session</interfacename> scope
                (<link linkend="beans-factory-scopes-session">described immediately above</link>),
                and really only makes sense in the context of portlet-based web applications.
                The portlet specification defines the notion of a global
                <interfacename>Session</interfacename> that is shared amongst all
                of the various portlets that make up a single portlet web application.
                Beans defined at the <literal>global session</literal> scope are scoped
                (or bound) to the lifetime of the global portlet
                <interfacename>Session</interfacename>.</para>
                <para>Please note that if you are writing a standard Servlet-based
                web application and you define one or more beans as having
                <literal>global session</literal> scope, the standard HTTP
                <interfacename>Session</interfacename> scope will be used, and no
                error will be raised.</para>
			</section>

			<section id="beans-factory-scopes-other-injection">
			    <title>Scoped beans as dependencies</title>
			    <para>Being able to define a bean scoped to a HTTP request or
			    <interfacename>Session</interfacename> (or indeed
			    <link linkend="beans-factory-scopes-custom">a custom scope</link>  of
			    your own devising) is all very well, but one of the
			    main value-adds of the Spring IoC container is that it manages
                not only the instantiation of your objects (beans), but also
			    the wiring up of collaborators (or dependencies). If you want to inject
			    a bean that, for the sake of argument is scoped at the HTTP request scope,
			    into another bean, you will need to inject an AOP proxy in place of the
			    scoped bean. That is to say, you need to inject a proxy object
			    that exposes the same public interface as the scoped object, but that is
			    smart enough to be able to retrieve the real, target object from
			    the relevant scope (for example a HTTP request) and delegate
			    method calls onto the real object.</para>
			    <note>
			        <para>You <emphasis>do not</emphasis> need to use the
			        <literal>&lt;aop:scoped-proxy/&gt;</literal> in conjunction with
			        beans that are scoped as <literal>singletons</literal> or
			        <literal>prototypes</literal>. It is an error to try to create a
			        scoped proxy for a singleton bean (and the resulting
			        <classname>BeanCreationException</classname> will certainly set
			        you straight in this regard).</para>
			    </note>
                <para>Let's look at the configuration that is required to effect this;
                it (the configuration) is not hugely difficult (just one line), but it
                is important to understand the <quote>why</quote> as well as the
                <quote>how</quote>.</para>
                    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

    ]]><lineannotation>&lt;!-- a HTTP <interfacename>Session</interfacename>-scoped bean exposed as a proxy --&gt;</lineannotation><![CDATA[
    <bean id="userPreferences" class="com.foo.UserPreferences" ]]><emphasis role="bold">scope="session"</emphasis>&gt;
          
          <lineannotation>&lt;!-- this next element effects the proxying of the surrounding bean --&gt;</lineannotation>
          <emphasis role="bold">&lt;aop:scoped-proxy/&gt;</emphasis><![CDATA[
    </bean>
    
    ]]><lineannotation>&lt;!-- a singleton-scoped bean <emphasis role="bold">injected with a proxy to the above bean</emphasis> --&gt;</lineannotation><![CDATA[
    <bean id="userService" class="com.foo.SimpleUserService">
    
        ]]><lineannotation>&lt;!-- a reference to the <emphasis role="bold">proxied</emphasis> <literal>'userPreferences'</literal> bean --&gt;</lineannotation><![CDATA[
        <property name="userPreferences" ref="userPreferences"/>

    </bean>
</beans>
]]></programlisting>
                <para>To create a proxy to a scoped bean using XML-based configuration, one need
                only insert a child <literal>&lt;aop:scoped-proxy/&gt;</literal> element into a
                scoped bean definition (you may also need the CGLIB library on your classpath
                so that the container can effect class-based proxying). The above XML configuration
                demonstrated the <quote>how</quote>; now for the <quote>why</quote>. So, just why
                does one need this <literal>&lt;aop:scoped-proxy/&gt;</literal> element in the
                definition of beans scoped at the <literal>request</literal>,
                <literal>session</literal>, and <literal>globalSession</literal> level? The
                reason why <literal>&lt;aop:scoped-proxy/&gt;</literal> is required is best
                explained by picking apart the following bean definition (please note that the
                following <literal>'userPreferences'</literal> bean definition as it stands is
                <emphasis>incomplete</emphasis>):</para>
                <programlisting><![CDATA[<bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>]]></programlisting>
                <para>From the above configuration it is evident to see that the singleton bean
                <literal>'userManager'</literal> is being injected with a reference to the HTTP
                <interfacename>Session</interfacename>-scoped bean <literal>'userPreferences'</literal>.
                The salient point here is that the <literal>'userManager'</literal> bean is a
                singleton... it will be instantiated <emphasis>exactly once</emphasis> per container,
                and it's dependencies (in this case only one, the <literal>'userPreferences'</literal>
                bean) will also only be injected once. This means that the
                <literal>'userManager'</literal> will (conceptually) only ever operate on the exact
                same <literal>'userPreferences'</literal> object, i.e. the one that it was originally
                injected with. This is not what one wants when one is injecting a HTTP
                <interfacename>Session</interfacename>-scoped bean as a dependency into a
                collaborating object. What we do want is a single <literal>'userManager'</literal> object,
                and then, for the lifetime of a HTTP <interfacename>Session</interfacename>, we want to
                see and use a <literal>'userPreferences'</literal> object that is specific to said
                HTTP <interfacename>Session</interfacename>.</para>
                <para>Rather what one needs then is to inject some sort of object that exposes the
                exact same public interface as the <classname>UserPreferences</classname> class (ideally
                an object that <emphasis>is a</emphasis> <classname>UserPreferences</classname> instance)
                and that is smart enough to be able to go off and fetch the
                <interfacename>real</interfacename> <classname>UserPreferences</classname> object from
                whatever underlying scoping mechanism we have chosen (HTTP request,
                <interfacename>Session</interfacename>, etc.). We can then safely inject this proxy
                object into the <literal>'userManager'</literal> bean, which will be blissfully unaware
                that the <classname>UserPreferences</classname> reference that it is holding onto is a
                proxy. In the case of this example, when a <interfacename>UserManager</interfacename>
                instance invokes a method on the dependency-injected <classname>UserPreferences</classname>
                object, it is really invoking a method on the proxy... the proxy will then go off and
                fetch the real <classname>UserPreferences</classname> object from (in this case) the HTTP
                <interfacename>Session</interfacename>, and delegate the method invocation onto the
                retrieved real <classname>UserPreferences</classname> object.</para>
                <para>That is why you need the following, correct and complete, configuration
                when injecting <literal>request-</literal>, <literal>session-</literal>, and
                <literal>globalSession-scoped</literal> beans into collaborating objects:</para>
                <programlisting><![CDATA[<bean id="userPreferences" class="com.foo.UserPreferences" scope="session">
    ]]><emphasis role="bold"><literal>&lt;aop:scoped-proxy/&gt;</literal></emphasis><![CDATA[
</bean>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>]]></programlisting>
			</section>
		</section>
		<section id="beans-factory-scopes-custom">
			<title>Custom scopes</title>
			<para>As of Spring 2.0, the bean scoping mechanism in Spring is extensible.
			This means that you are not limited to just the bean scopes that Spring
			provides out of the box; you can define your own scopes, or even redefine
			the existing scopes (although that last one would probably be considered
			bad practice - please note that you <emphasis>cannot</emphasis> override the
			built-in <literal>singleton</literal> and <literal>prototype</literal> scopes).</para>
			<para>Scopes are defined by the
			<interfacename>org.springframework.beans.factory.config.Scope</interfacename>
			interface. This is the interface that you will need to implement in order
			to integrate your own custom scope(s) into the Spring container. The interface
			itself is quite simple, with two methods to get and remove an object from/to
			an underlying storage mechanism respectively. Possible custom scopes are
			beyond the scope of this reference manual. You may wish to look at the
			<interfacename>Scope</interfacename> implementations that are supplied with
			Spring for an idea of how to go about writing your own implementation.</para>
			<para>The remainder of this section details how, after you have written and
			tested one or more custom <interfacename>Scope</interfacename> implementations,
			you then go about making the Spring container aware of your new scope. The
			central method to register a new <interfacename>Scope</interfacename> with the
			Spring container is declared on the <interfacename>ConfigurableBeanFactory</interfacename>
			interface (implemented by most of the concrete <interfacename>BeanFactory</interfacename>
			implementations that ship with Spring); this central method is displayed below:</para>
			<programlisting><![CDATA[void registerScope(String scopeName, Scope scope);]]></programlisting>
			<para>The first argument to the <methodname>registerScope(..)</methodname> method is the
			unique name associated with a scope; examples of such names in the Spring container
			itself are <literal>'singleton'</literal> and <literal>'prototype'</literal>.
			The second argument to the <methodname>registerScope(..)</methodname> method is an
			actual instance of the custom <interfacename>Scope</interfacename> implementation
			that you wish to register and use.</para>
			<para>Let's assume that you have written your own custom
			<interfacename>Scope</interfacename> implementation, and you have registered it
			like so:</para>
			    <programlisting><lineannotation>// note: the <classname>ThreadScope</classname> class does <emphasis role="bold">not</emphasis> exist; I just made it up for the sake of this example</lineannotation><![CDATA[
Scope customScope = new ThreadScope();
beanFactory.registerScope("]]><emphasis role="bold">thread</emphasis><![CDATA[", scope);]]></programlisting>
            <para>You can then create bean definitions that adhere to the scoping rules of your
            custom <interfacename>Scope</interfacename> like so:</para>
            <programlisting>&lt;bean id="..." class="..." <emphasis role="bold">scope="thread"</emphasis>/&gt;</programlisting>
            <para>If you have your own custom <interfacename>Scope</interfacename> implementation(s),
            you are not just limited to only programmatic registration of said custom scope(s).
            You can also do the <interfacename>Scope</interfacename> registration declaratively,
            using a custom <interfacename>BeanFactoryPostProcessor</interfacename>
            implementation, the <classname>CustomScopeConfigurer</classname> class. The
            <interfacename>BeanFactoryPostProcessor</interfacename> interface is one of the
            primary means of extending the Spring IoC container, and is described in a
            <link linkend="beans-factory-extension-factory-postprocessors">later section</link>
            of this very chapter.</para>
            <para>The declarative registration of custom <interfacename>Scope</interfacename>
            implementations using the <classname>CustomScopeConfigurer</classname> class is
            shown below:</para>
                <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">

    <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
        <property name="scopes">
            <map>
                ]]><emphasis role="bold">&lt;entry key="thread" value="com.foo.ThreadScope"/&gt;</emphasis><![CDATA[
            </map>
        </property>
    </bean>

    <bean id="bar" class="x.y.Bar" ]]><emphasis role="bold">scope="thread"</emphasis><![CDATA[>
        <property name="name" value="Rick"/>
        <aop:scoped-proxy/>
    </bean>

    <bean id="foo" class="x.y.Foo">
        <property name="bar" ref="bar"/>
    </bean>

</beans>]]></programlisting>
            <para>The <classname>CustomScopeConfigurer</classname> also allows you to specify
            actual <classname>Class</classname> instances as entry values, as well as
            actual <interfacename>Scope</interfacename> implementation instances; see the
            Javadocs for the <classname>CustomScopeConfigurer</classname> class for details.</para>
		</section>
    </section>
    <section id="beans-factory-nature">
        <title>Customizing the nature of a bean</title>
        <section id="beans-factory-lifecycle">
            <title>Lifecycle interfaces</title>
            <para>Spring provides several marker interfaces to change the behavior
      of your bean in the container. They include
      <interfacename>InitializingBean</interfacename> and
      <interfacename>DisposableBean</interfacename>. Implementing these interfaces will
      result in the container calling
      <literal>afterPropertiesSet()</literal> for the former and
      <literal>destroy()</literal> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</para>
            <para>Internally, Spring uses <interfacename>BeanPostProcessor</interfacename> implementations to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <interfacename>BeanPostProcessor</interfacename> yourself. More information about
      this can be found in <xref linkend="beans-factory-extension" />.</para>
            <para>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</para>
            <section id="beans-factory-lifecycle-initializingbean">
                <title>Initialization callbacks</title>
                <para>Implementing the
                <literal>org.springframework.beans.factory.InitializingBean</literal>
                allows a bean to perform initialization work after all necessary
                properties on the bean are set by the container. The
                <interfacename>InitializingBean</interfacename> interface specifies exactly one
                method:</para>
                <programlisting><![CDATA[void afterPropertiesSet() throws Exception;]]></programlisting>
                <para>Generally, the use of the <interfacename>InitializingBean</interfacename>
                interface can be avoided (and is discouraged since it unnecessarily couples
                the code to Spring). A bean definition provides support for a generic
                initialization method to be specified. In the case of XML-based configuration
                metadata, this is done using the <literal>'init-method'</literal> attribute.
                For example, the following definition:</para>
                <programlisting><![CDATA[<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>]]></programlisting>
                <programlisting><![CDATA[public class ExampleBean {
    
    public void init() {
        ]]><lineannotation>// do some initialization work</lineannotation><![CDATA[
    }
}]]></programlisting>
		        <para>Is exactly the same as...</para>
		        <programlisting><![CDATA[<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>]]></programlisting>
                <programlisting><![CDATA[public class AnotherExampleBean implements InitializingBean {
    
    public void afterPropertiesSet() {
        ]]><lineannotation>// do some initialization work</lineannotation><![CDATA[
    }
}]]></programlisting>
				<para>... but does not couple the code to Spring.</para>
            </section>
            <section id="beans-factory-lifecycle-disposablebean">
                <title>Destruction callbacks</title>
                <para>Implementing the
                <interfacename>org.springframework.beans.factory.DisposableBean</interfacename>
                interface allows a bean to get a callback when the container
                containing it is destroyed. The <interfacename>DisposableBean</interfacename> interface specifies one
                method:</para>
                <programlisting><![CDATA[void destroy() throws Exception;]]></programlisting>
                <para>Generally, the use of the
                <interfacename>DisposableBean</interfacename> marker interface can be avoided (and
                is discouraged since it unnecessarily couples the code to Spring). A
                bean definition provides support for a generic destroy method to be
                specified. When using XML-based configuration metadata this is done via the
                <literal>'destroy-method'</literal> attribute on the <literal>&lt;bean/&gt;</literal>.
                For example, the following definition: </para>
                <programlisting><![CDATA[<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>]]></programlisting>

                <programlisting><![CDATA[public class ExampleBean {

    public void cleanup() {
        ]]><lineannotation>// do some destruction work (like releasing pooled connections)</lineannotation><![CDATA[
    }
}]]></programlisting>
                <para>Is exactly the same as...</para>
			<programlisting><![CDATA[<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>]]></programlisting>

                <programlisting><![CDATA[public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        ]]><lineannotation>// do some destruction work (like releasing pooled connections)</lineannotation><![CDATA[
    }
}]]></programlisting>
			<para>... but does not couple the code to Spring.</para>
                <section id="beans-factory-lifecycle-default-init-destroy-methods">
                    <title>Default initialization &amp; destroy methods</title>
                    <para>
                        When one is writing initialization and destroy method callbacks that do not
                        use the Spring-specific <interfacename>InitializingBean</interfacename>
                        and <interfacename>DisposableBean</interfacename> callback interfaces,
                        one (in the experience of this author) typically finds oneself writing
                        methods with names such as <literal>init()</literal>,
                        <literal>initialize()</literal>, <literal>dispose()</literal>,
                        <literal>destroy()</literal>, etc. The names of such lifecycle callback
                        methods are (hopefully!) standardized across a project so that developers
                        on a team all use the same method names and thus ensure some level of
                        consistency.
                    </para>
                    <para>
                        The Spring container can now be configured to <literal>'look'</literal>
                        for named initialization and destroy callback method names on
                        <emphasis>every</emphasis> bean. This means that you as an application developer
                        can simply write your application classes, use a convention of having an
                        initialization callback called <literal>init()</literal>, and then
                        (without having to configure each and every bean with, in the case of XML-based
                        configuration, an <literal>'init-method="init"'</literal> attribute)
                        be safe in the knowledge that the Spring IoC container <emphasis>will</emphasis>
                        call that method when the bean is being created (and in accordance with the
                        standard lifecycle callback contract described previously).
                    </para>
                    <para>
                        Let's look at an example to make the use of this feature completely clear.
                        For the sake of the example, let us say that one of the coding conventions on a
                        project is that all initialization callback methods are to be named
                        <literal>init()</literal> and that destroy callback methods are to be called
                        <literal>destroy()</literal>. This leads to classes like so...
                    </para>
                    <programlisting><![CDATA[public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    ]]><lineannotation>// this is (unsurprisingly) the initialization callback method</lineannotation><![CDATA[
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}]]></programlisting>
            <para>
                The attendant XML configuration for the above class, and making use of the
                by-convention initialization callback method configuration, would look like
                so:
            </para>
            <programlisting><![CDATA[<beans ]]><emphasis role="bold">default-init-method="init"</emphasis><![CDATA[>

    <bean id="blogService" class="com.foo.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>]]></programlisting>
                    <para>
                        Notice the use of the <literal>'default-init-method'</literal> attribute on the
                        top-level <literal>&lt;beans/&gt;</literal> element. The presence of this
                        attribute means that the Spring IoC container will recognize a method called
                        <literal>'init'</literal> on beans as being the initialization method callback,
                        and when a bean is being created and assembled, if the bean's class has such
                        a method, it will be invoked at the appropriate time.
                    </para>
                    <para>
                        Destroy method callbacks are configured similarly (in XML that is) using the
                        <literal>'default-destroy-method'</literal> attribute on the top-level
                        <literal>&lt;beans/&gt;</literal> element.
                    </para>
                    <para>
                        The use of this feature can save you the (small) housekeeping chore of specifying
                        an initialization and destroy method callback on each and every bean, and it is
                        great for enforcing a consistent naming convention for initialization and destroy
                        method callbacks (and consistency is something that should always be aimed for).
                    </para>
                    <para>
                        One final word... let's say you want to use this feature, but you have some
                        existing beans where the underlying classes already have for example initialization
                        callback methods that are named at variance with the convention. You can
                        <emphasis>always</emphasis> override the default by specifying (in XML that is)
                        the method name using the <literal>'init-method'</literal> and
                        <literal>'destroy-method'</literal> attributes on the <literal>&lt;bean/&gt;</literal>
                        element itself.
                    </para>
                </section>
                <section>
                    <title>Shutting down the Spring IoC container gracefully in non-web applications</title>
                    <note>
                        <para>This next section does not apply to web applications (in case the title of this section
                        did not make that abundantly clear). Spring's web-based <interfacename>ApplicationContext</interfacename>
                        implementations already have code in place to handle shutting down the Spring
                        IoC container gracefully when the relevant web application is being shutdown.</para>
                    </note>
                    <para>If you are using Spring's IoC container in a non-web application environment, for
                    example in a rich client desktop environment, and you want the container to shutdown
                    gracefully and call the relevant destroy callbacks on your singleton beans, you will
                    need to register a shutdown hook with the JVM. This is quite easy to do (see below),
                    and will ensure that your Spring IoC container shuts down gracefully and that all
                    resources held by your singletons are released (of course it is still up to you to both
                    configure the destroy callbacks for your singletons and implement such
                    destroy callbacks correctly).</para>
                    <para>So to register a shutdown hook that enables the graceful shutdown of the relevant
                    Spring IoC container, you simply need to call the
                    <methodname>registerShutdownHook()</methodname> method that is declared on the
                    <classname>AbstractApplicationContext</classname> class. To wit...</para>
                    <programlisting><![CDATA[import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        ]]><lineannotation>// add a shutdown hook for the above context... </lineannotation><![CDATA[
        ctx.registerShutdownHook();

        ]]><lineannotation>// app runs here...</lineannotation><![CDATA[

        ]]><lineannotation>// main method exits, hook is called prior to the app shutting down...</lineannotation><![CDATA[
    }
}]]></programlisting>
                </section>
            </section>
        </section>
        <section id="beans-factory-aware">
            <title>Knowing who you are</title>
            <section id="beans-factory-aware-beanfactoryaware">
                <title>
                    <interfacename>BeanFactoryAware</interfacename>
                </title>
                <para>A class which implements the
        <interfacename>org.springframework.beans.factory.BeanFactoryAware</interfacename>
        interface is provided with a reference to the <interfacename>BeanFactory</interfacename> that created
        it, when it is created by that <interfacename>BeanFactory</interfacename>.
        </para>
                <programlisting><![CDATA[public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}]]></programlisting>
                <para>
            This allows beans to manipulate the <interfacename>BeanFactory</interfacename>
            that created them programmatically, through the <interfacename>BeanFactory</interfacename>
            interface, or by casting the reference to a known subclass of this
            which exposes additional functionality. Primarily this would consist
            of programmatic retrieval of other beans. While there are cases when
            this capability is useful, it should generally be avoided, since it
            couples the code to Spring, and does not follow the Inversion of
            Control style, where collaborators are provided to beans as properties.
        </para>
                <para>An alternative option that is equivalent in effect to the
                <interfacename>BeanFactoryAware</interfacename>-based approach is to use the
                <classname>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</classname>.
                (It should be noted that this approach still does not reduce the coupling to Spring,
                but it does not violate the central principal of IoC as much as the
                <interfacename>BeanFactoryAware</interfacename>-based approach.)</para>
                <para>The <classname>ObjectFactoryCreatingFactoryBean</classname> is a
                <link linkend="beans-factory-extension-factorybean"><interfacename>FactoryBean</interfacename></link>
                implementation that returns a reference to an object (factory) that can in turn be used to
                effect a bean lookup. The <classname>ObjectFactoryCreatingFactoryBean</classname> class
                does itself implement the <interfacename>BeanFactoryAware</interfacename> interface;
                what client beans are actually injected with is an instance of the
                <interfacename>ObjectFactory</interfacename> interface. This is a Spring-specific
                interface (and hence there is still no total decoupling from Spring), but clients
                can then use the <interfacename>ObjectFactory</interfacename>'s
                <methodname>getObject()</methodname> method to effect the bean lookup (under the hood the
                <interfacename>ObjectFactory</interfacename> implementation instance that is returned
                simply delegates down to a <interfacename>BeanFactory</interfacename> to actually
                lookup a bean by name). All that one need do is supply
                the <classname>ObjectFactoryCreatingFactoryBean</classname> with the name of the
                bean that is to be looked up. Let's look at an example:</para>
                <programlisting><![CDATA[package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}]]></programlisting>
                <programlisting><![CDATA[package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hardcode the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}]]></programlisting>
                <para>
            Find below the XML configuration to wire together the above classes
            using the <classname>ObjectFactoryCreatingFactoryBean</classname> approach.
        </para>
                <programlisting><![CDATA[<beans>
    <bean id="newsFeedManager" class="x.y.NewsFeedManager">
        <property name="factory">
            <bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean">
                <property name="targetBeanName">
                    <idref local="newsFeed" />
                </property>
            </bean>
        </property>
    </bean>
    <bean id="newsFeed" class="x.y.NewsFeed" singleton="false">
        <property name="news" value="... that's fit to print!" />
    </bean>
</beans>]]></programlisting>
                <para>
            And here is a small driver program to test the fact that new (prototype)
            instances of the <literal>newsFeed</literal> bean are actually being returned for
            each call to the injected <interfacename>ObjectFactory</interfacename> inside the
            <classname>NewsFeedManager</classname>'s <methodname>printNews()</methodname> method.
        </para>
                <programlisting><![CDATA[import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}]]></programlisting>
                <para>
            The output from running the above program will look like so (results will of course vary
            on your machine).
        </para>
                <programlisting><![CDATA[x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!']]></programlisting>
                <para>
            The interested reader may also find the <classname>ServiceLocatorFactoryBean</classname>
            (in the <literal>org.springframework.beans.factory.config</literal> package) to be
            of use... the approach is similar to that of the
            <classname>ObjectFactoryCreatingFactoryBean</classname>, but it allows one
            to specify one's own lookup interface as opposed to having to use a Spring-specific
            lookup interface such as the <interfacename>ObjectFactory</interfacename>.
            Consult the (copious) Javadocs for the <classname>ServiceLocatorFactoryBean</classname>
            for a full treatment of this alternative approach (that <emphasis>does</emphasis>
            reduce the coupling to Spring).
        </para>
            </section>
            <section id="beans-factory-aware-beannameaware">
                <title>BeanNameAware</title>
                <para>If a bean implements the
        <literal>org.springframework.beans.factory.BeanNameAware</literal>
        interface and is deployed in a <interfacename>BeanFactory</interfacename>, the <interfacename>BeanFactory</interfacename> will call
        the bean through this interface to inform the bean of the
        <emphasis>id</emphasis> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <interfacename>InitializingBean</interfacename>'s
        <emphasis>afterPropertiesSet</emphasis> or a custom
        init-method.</para>
            </section>
        </section>
    </section>
    <section id="beans-child-bean-definitions">
        <title>Abstract and child bean definitions</title>
        <para>A bean definition potentially contains a large amount of
        configuration information, including container specific information (i.e.
        initialization method, static factory method name, etc.) and constructor
        arguments and property values. A child bean definition is a bean
        definition which inherits configuration data from a parent definition. It
        is then able to override some values, or add others, as needed. Using
        parent and child bean definitions can potentially save a lot of typing.
        Effectively, this is a form of templating.</para>
        <para>When working with a <interfacename>BeanFactory</interfacename> programmatically, child bean
        definitions are represented by the <classname>ChildBeanDefinition</classname>
        class. Most users will never work with them on this level, instead
        configuring bean definitions declaratively in something like the
        <classname>XmlBeanFactory</classname>. When using XML-based configuration metadata a child bean
        definition is indicated simply by using the <literal>'parent'</literal>
        attribute, specifying the parent bean as the value of this attribute.</para>
        
        <programlisting><![CDATA[<bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean">
  <property name="name" value="parent"/>
  <property name="age" value="1"/>
</bean>

<bean id="inheritsWithDifferentClass"
      class="org.springframework.beans.DerivedTestBean"
      ]]><emphasis role="bold">parent="inheritedTestBean"</emphasis><![CDATA[ init-method="initialize">
    
  <property name="name" value="override"/>
  ]]><lineannotation>&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</lineannotation><![CDATA[

</bean>]]></programlisting>
        
        <para>A child bean definition will use the bean class from the parent
        definition if none is specified, but can also override it. In the latter
        case, the child bean class must be compatible with the parent, i.e. it
        must accept the parent's property values.</para>
        <para>A child bean definition will inherit constructor argument values,
        property values and method overrides from the parent, with the option to
        add new values. If init method, destroy method and/or <literal>static</literal>
        factory method are specified, they will override the corresponding parent
        settings.</para>
        <para>The remaining settings will <emphasis>always</emphasis> be taken
        from the child definition: <emphasis>depends on</emphasis>,
        <emphasis>autowire mode</emphasis>, <emphasis>dependency check</emphasis>,
        <emphasis>singleton</emphasis>, <emphasis>lazy init</emphasis>.</para>
        <para>Note that in the example above, we have explicitly marked the parent
        bean definition as <emphasis>abstract</emphasis> by using the
        <emphasis>abstract</emphasis> attribute. In the case that the parent
        definition does not specify a class:</para>
    
        <programlisting><![CDATA[<bean id="inheritedTestBeanWithoutClass">
    <property name="name" value="parent"/>
    <property name="age" value="1"/>
</bean>

<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize">
  <property name="name" value="override"/>
  ]]><lineannotation>&lt;!-- age will inherit value of 1 from parent --&gt;</lineannotation><![CDATA[
</bean>]]></programlisting>

        <para>The parent bean cannot get instantiated on its own since it is
        incomplete, and it is also defined as abstract. When a definition is
        defined to be abstract like this (explicitly or implicitly), it is
        usable only as a pure template bean definition that will serve as parent
        definition for child definitions. Trying to use such an abstract parent
        bean on its own (by referring to it as a ref property of another bean, or
        doing an explicit <methodname>getBean()</methodname> call with the parent
        bean id), will result in an error. Similarly, the container's internal
        <methodname>preInstantiateSingletons()</methodname> method will completely
        ignore bean definitions which are defined as abstract.</para>
        
        <note>
            <para><literal>ApplicationContexts</literal> (but <emphasis>not</emphasis>
            <literal>BeanFactories</literal>) will by default pre-instantiate
            all singletons. therefore it is important (at least for singleton beans)
            that if you have a (parent) bean definition which you intend to use only
            as a template, and this definition specifies a class, you must make sure
            to set the <emphasis>abstract</emphasis> attribute to <emphasis>true</emphasis>,
            otherwise the application context will actually (attempt to) pre-instantiate
            it.</para>
        </note>
    </section>
    
    <section id="beans-factory-extension">
        <title>Container extension points</title>
        <para>The IoC component of the Spring Framework has been designed for extension.
        There is typically no need for an application developer to subclass any of the various
        <interfacename>BeanFactory</interfacename> or <interfacename>ApplicationContext</interfacename>
        implementation classes. The Spring IoC container can be infinitely extended by
        plugging in implementations of special integration interfaces. The next few sections are
        devoted to detailing all of these various integration interfaces.</para>

        <section id="beans-factory-extension-bpp">
            <title>Customizing beans using <literal>BeanPostProcessors</literal></title>
            <para>The first extension point that we will look at is the
            <interfacename>BeanPostProcessor</interfacename> interface. This interface defines
            a number of <firstterm>callback methods</firstterm> that you as an application
            developer can implement in order to provide your own (or override the containers default)
            instantiation logic, dependency-resolution logic, and so forth. If you want to do
            some custom logic after the Spring container has finished instantiating, configuring
            and otherwise initializing a bean, you can plug in one or more
            <interfacename>BeanPostProcessor</interfacename> implementations.</para>
            <para>You can configure multiple <literal>BeanPostProcessors</literal> if you wish.
            You can control the order in which these <literal>BeanPostProcessors</literal>
            execute by setting the <literal>'order'</literal> property (you can only set this property 
            if the <interfacename>BeanPostProcessor</interfacename>
            implements the <interfacename>Ordered</interfacename> interface; if you write your own
            <interfacename>BeanPostProcessor</interfacename> you should consider implementing the
            <interfacename>Ordered</interfacename> interface too); consult the Javadocs for the
            <interfacename>BeanPostProcessor</interfacename> and <interfacename>Ordered</interfacename>
            interfaces for more details.</para>
            <note>
                <para><literal>BeanPostProcessors</literal> operate on bean (or object)
                <emphasis>instances</emphasis>; that is to say, the Spring IoC container will
                have instantiated a bean instance for you, and <emphasis>then</emphasis>
                <literal>BeanPostProcessors</literal> get a chance to do their stuff.</para>
                <para>If you want to change the actual bean definition (i.e. the recipe that
                defines the bean), then you rather need to use a
                <interfacename>BeanFactoryPostProcessor</interfacename> (described below in the
                section entitled <xref linkend="beans-factory-extension-factory-postprocessors"/>.</para>
                <para>Also, <literal>BeanPostProcessors</literal> are scoped <emphasis>per-container</emphasis>.
                This is only relevant if you are using container hierarchies. If you define a
                <interfacename>BeanPostProcessor</interfacename> in one container, it will
                <emphasis>only</emphasis> do its stuff on the beans in that container. Beans that
                are defined in another container will not be post-processed by
                <literal>BeanPostProcessors</literal> in another container, even if both containers
                are part of the same hierarchy.</para>
            </note>
            <para>The <interfacename>org.springframework.beans.factory.config.BeanPostProcessor</interfacename>
            interface consists of exactly two callback methods. When such a class is
            registered as a post-processor with the container (see below for how this registration
            is effected), for each bean instance that is created by the container, the post-processor
            will get a callback from the container both <emphasis>before</emphasis> any container
            initialization methods (such as <emphasis>afterPropertiesSet</emphasis> and any declared
            init method) are called, and also afterwards. The post-processor is free to do what it
            wishes with the bean instance, including ignoring the callback completely. A bean
            post-processor will typically check for marker interfaces, or do something such as wrap
            a bean with a proxy; some of the Spring AOP infrastructure classes are implemented as bean
            post-processors and they do this proxy-wrapping logic.</para>
            <para>It is important to know that a <interfacename>BeanFactory</interfacename> treats bean
            post-processors slightly differently than an <interfacename>ApplicationContext</interfacename>.
            An <interfacename>ApplicationContext</interfacename> will <emphasis>automatically detect</emphasis>
            any beans which are defined in the configuration metadata which is supplied to it that
            implement the <interfacename>BeanPostProcessor</interfacename> interface, and register them
            as post-processors, to be then called appropriately by the container on bean creation. Nothing
            else needs to be done other than deploying the post-processor in a similar fashion to any
            other bean. On the other hand, when using a <interfacename>BeanFactory</interfacename>
            implementation, bean post-processors explcitly have to be registered, with code like this:</para>
            <programlisting><![CDATA[ConfigurableBeanFactory factory = new XmlBeanFactory(...);
            
    ]]><lineannotation>// now register any needed <interfacename>BeanPostProcessor</interfacename> instances</lineannotation><![CDATA[
    MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
    factory.addBeanPostProcessor(postProcessor);

    ]]><lineannotation>// now start using the factory</lineannotation></programlisting>
            <para>This explicit registration step is not convenient, and this is one of the
            reasons why the various <interfacename>ApplicationContext</interfacename>
            implementations are preferred above plain <interfacename>BeanFactory</interfacename>
            implementations in the vast majority of Spring-backed applications, especially
            when using <literal>BeanPostProcessors</literal>.</para>
            <note>
                <para>You typically don't want to have <literal>BeanPostProcessors</literal>
                marked as being lazily-initialized. If they are marked as such, then the Spring
                container will never instantiate them, and thus they won't get a chance
                to apply their custom logic. If you are using the
                <literal>'default-lazy-init'</literal> attribute on the declaration of your
                <literal>&lt;beans/&gt;</literal> element, be sure to mark your various
                <interfacename>BeanPostProcessor</interfacename> bean definitions with
                <literal>'lazy-init="false"'</literal>.
                </para>
            </note>
            <para>Find below some examples of how to write, register, and use
            <literal>BeanPostProcessors</literal> in the context of an
            <interfacename>ApplicationContext</interfacename>.</para>
            <section id="beans-factory-extension-bpp-examples-hw">
                <title>Example: Hello World, <interfacename>BeanPostProcessor</interfacename>-style</title>
                <para>This first example is hardly compelling, but serves to illustrate basic
                usage. All we are going to do is code a custom <interfacename>BeanPostProcessor</interfacename>
                implementation that simply invokes the <methodname>toString()</methodname>
                method of each bean as it is created by the container and prints the resulting
                string to the system console. Yes, it is not hugely useful, but serves to get
                the basic concepts across before we move into the second example which
                <emphasis>is</emphasis> actually useful.</para>
                <para>Find below the custom <interfacename>BeanPostProcessor</interfacename>
                implementation class definition:</para>
                <programlisting><![CDATA[package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.BeansException;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    ]]><lineannotation>// simply return the instantiated bean as-is</lineannotation><![CDATA[
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean; ]]><lineannotation>// we could potentially return <emphasis>any</emphasis> object reference here...</lineannotation><![CDATA[
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}]]></programlisting>
                <para>Here is the attendant XML-based configuration:</para>
                <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd">

    <lang:groovy id="messenger"
          script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
        <lang:property name="message" value="Fiona Apple Is Just So Dreamy."/> 
    </lang:groovy>
    
    ]]><lineannotation>&lt;!-- 
        when the above bean ('messenger') is instantiated, this custom
        <interfacename>BeanPostProcessor</interfacename> implementation will output the fact to the system console
     --&gt;</lineannotation><![CDATA[
    <bean class="scripting.InstantiationTracingBeanPostProcessor"/>

</beans>]]></programlisting>
                <para>Notice how the <classname>InstantiationTracingBeanPostProcessor</classname> is
                simply defined; it doesn't even have a name, and because it is a bean it can be
                dependency injected just like any other bean. (The above configuration also just so
                happens to define a bean that is backed by a Groovy script. The Spring 2.0 dynamic
                language support is detailed in the chapter entitled
                <xref linkend="dynamic-language"/>.)</para>
                <para>Find below a small driver script to exercise the above code and
                configuration;</para>
                <programlisting><![CDATA[import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger);
    }
}]]></programlisting>
                <para>The output of executing the above program will be (something like) this:</para>
                <programlisting><![CDATA[Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961]]></programlisting>
            </section>
            <section id="beans-factory-extension-bpp-examples-rabpp">
                <title>Example: The <classname>RequiredAnnotationBeanPostProcessor</classname></title>
                <para>Using marker interfaces or annotations in conjunction with a custom
                <interfacename>BeanPostProcessor</interfacename> implementation is a common
                means of extending the Spring IoC container. This next example is a bit of
                a cop-out, in that you are directed to the section entitled
                <xref linkend="metadata-annotations-required"/> which demonstrates the usage of a
                custom <interfacename>BeanPostProcessor</interfacename> implementation that
                that ships with the Spring distribution which ensures that JavaBean properties on
                beans that are marked with an (arbitrary) annotation are actually (configured to
                be) dependency-injected with a value.</para>
            </section>
        </section>

        <section id="beans-factory-extension-factory-postprocessors">
            <title>Customizing configuration metadata with <literal>BeanFactoryPostProcessors</literal></title>
            <para>The next extension point that we will look at is the
            <interfacename>org.springframework.beans.factory.config.BeanFactoryPostProcessor</interfacename>.
            This semantics of this interface are similar to the <interfacename>BeanPostProcessor</interfacename>,
            with one major difference. <literal>BeanFactoryPostProcessors</literal> operate on
            bean definitions (i.e. the configuration metadata that is supplied to a container); that is to say,
            the Spring IoC container will allow <literal>BeanFactoryPostProcessors</literal> to read the
            configuration metadata and potentially change it <emphasis>before</emphasis> the
            container has actually instantied any other beans.</para>
            <para>You can configure multiple <literal>BeanFactoryPostProcessors</literal> if you wish.
            You can control the order in which these <literal>BeanFactoryPostProcessors</literal>
            execute by setting the <literal>'order'</literal> property (you can only set this property 
            if the <interfacename>BeanFactoryPostProcessor</interfacename>
            implements the <interfacename>Ordered</interfacename> interface; if you write your own
            <interfacename>BeanFactoryPostProcessor</interfacename> you should consider
            implementing the <interfacename>Ordered</interfacename> interface too); consult
            the Javadocs for the <interfacename>BeanFactoryPostProcessor</interfacename>
            and <interfacename>Ordered</interfacename> interfaces for more details.</para>
            <note>
                <para>If you want to change the actual bean <emphasis>instances</emphasis>
                (i.e. the objects that are created from the configuration metadata), then
                you rather need to use a <interfacename>BeanPostProcessor</interfacename>
                (described above in the section entitled
                <xref linkend="beans-factory-extension-bpp"/>.</para>
                <para>Also, <literal>BeanFactoryPostProcessors</literal> are scoped
                <emphasis>per-container</emphasis>. This is only relevant if you are
                using container hierarchies. If you define a
                <interfacename>BeanFactoryPostProcessor</interfacename> in one container,
                it will <emphasis>only</emphasis> do its stuff on the bean definitions in
                that container. Bean definitions in another container will not be
                post-processed by <literal>BeanFactoryPostProcessors</literal> in another
                container, even if both containers are part of the same hierarchy.</para>
            </note>
            <para>A bean factory post-processor is executed manually (in the case of a
            <interfacename>BeanFactory</interfacename>) or automatically (in the case of a
            <interfacename>ApplicationContext</interfacename>) to apply changes of
            some sort to the configuration metadata that defines a container. Spring
            includes a number of pre-existing bean factory post-processors, such as
            <classname>PropertyResourceConfigurer</classname> and
            <classname>PropertyPlaceHolderConfigurer</classname>, both described below,
            and <classname>BeanNameAutoProxyCreator</classname>, which is very useful for wrapping
            other beans transactionally or with any other kind of proxy, as described
            later in this manual. The <interfacename>BeanFactoryPostProcessor</interfacename>
            can be used to add custom property editors.</para>
            <para>In a <interfacename>BeanFactory</interfacename>, the process of applying a
            <interfacename>BeanFactoryPostProcessor</interfacename> is manual, and will be
            similar to this:</para>
            <programlisting><![CDATA[XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));

]]><lineannotation>// bring in some property values from a <classname>Properties</classname> file</lineannotation><![CDATA[
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

]]><lineannotation>// now actually do the replacement</lineannotation><![CDATA[
cfg.postProcessBeanFactory(factory);]]></programlisting>
            <anchor id="beans-factory-autodetect-beanfactorypostprocessors"/>
            <para>An <interfacename>ApplicationContext</interfacename> will detect any beans which
            are deployed into it which implement the <interfacename>BeanFactoryPostProcessor</interfacename>
            interface, and automatically use them as bean factory post-processors, at the appropriate
            time. Nothing else needs to be done other than deploying these post-processor in a similar
            fashion to any other bean.</para>
            <para>This explicit registration step is not convenient, and this is one of the
            reasons why the various <interfacename>ApplicationContext</interfacename>
            implementations are preferred above plain <interfacename>BeanFactory</interfacename>
            implementations in the vast majority of Spring-backed applications, especially
            when using <literal>BeanFactoryPostProcessors</literal>.</para>
            <note>
                <para>Just as in the case of <literal>BeanPostProcessors</literal>, you typically
                don't want to have <literal>BeanFactoryPostProcessors</literal>
                marked as being lazily-initialized. If they are marked as such, then the Spring
                container will never instantiate them, and thus they won't get a chance
                to apply their custom logic. If you are using the
                <literal>'default-lazy-init'</literal> attribute on the declaration of your
                <literal>&lt;beans/&gt;</literal> element, be sure to mark your various
                <interfacename>BeanFactoryPostProcessor</interfacename> bean definitions with
                <literal>'lazy-init="false"'</literal>.
                </para>
            </note>
            <section id="beans-factory-placeholderconfigurer">
                <title>Example: the <interfacename>PropertyPlaceholderConfigurer</interfacename></title>
                <para>The <interfacename>PropertyPlaceholderConfigurer</interfacename>, implemented
                as a bean factory post-processor, is used to externalize some property
                values from a <interfacename>BeanFactory</interfacename> definition, into another
                separate file in the standard Java <classname>Properties</classname> format.
                This is useful to allow the person deploying an application to customize some key
                properties (for example database URLs, usernames and passwords), without the
                complexity or risk of modifying the main XML definition file or files for the
                container.</para>
                <para>Consider the following XML-based configuration metadata fragment, where a
                <interfacename>DataSource</interfacename> with placeholder values is defined. We
                will configure some properties from an external <classname>Properties</classname>
                file, and at runtime, we will apply a
                <classname>PropertyPlaceholderConfigurer</classname> to the metadata which will
                replace some properties of the datasource:</para>
                <programlisting><![CDATA[<bean id="dataSource" destroy-method="close"
      class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="]]><emphasis role="bold">${jdbc.driverClassName}</emphasis><![CDATA["/>
    <property name="url" value="]]><emphasis role="bold">${jdbc.url}</emphasis><![CDATA["/>
    <property name="username" value="]]><emphasis role="bold">jdbc.username</emphasis><![CDATA["/>
    <property name="password" value="]]><emphasis role="bold">${jdbc.password}</emphasis><![CDATA["/>
</bean>]]></programlisting>
                <para>The actual values come from another file in the standard Java
                <classname>Properties</classname> format:</para>
                <programlisting><![CDATA[jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root]]></programlisting>
                <para>The <classname>PropertyPlaceHolderConfigurer</classname> doesn't only
				look for properties in the <classname>Properties</classname> file you
				specify, but also checks against the Java <classname>System</classname>
				properties if it cannot find a property you are trying to use. This
				behavior can be customized by setting the <literal>systemPropertiesMode</literal>
				property of the configurer. It has three values, one to tell the configurer
				to always override, one to let it <emphasis>never</emphasis> override and
				one to let it override only if the property cannot be found in the
				properties file specified. Please consult the Javadoc for the
				<classname>PropertiesPlaceholderConfigurer</classname> for more information.</para>
            </section>
            <section id="beans-factory-overrideconfigurer">
                <title>Example: the <classname>PropertyOverrideConfigurer</classname></title>
                <para>The <classname>PropertyOverrideConfigurer</classname>, another bean
                factory post-processor, is similar to the
                <interfacename>PropertyPlaceholderConfigurer</interfacename>, but in contrast to the
                latter, the original definitions can have default values or no values at
                all for bean properties. If an overriding <classname>Properties</classname> file
                does not have an entry for a certain bean property, the default context definition
                is used.</para>
                <para>Note that the bean factory definition is <emphasis>not</emphasis>
                aware of being overridden, so it is not immediately obvious when looking
                at the XML definition file that the override configurer is being used.
                In case that there are multiple <classname>PropertyOverrideConfigurer</classname>
                instances that define different values for the same bean property, the last one
                will win (due to the overriding mechanism).</para>
                <para>Properties file configuration lines are expected to be in the format:</para>
			    <programlisting><![CDATA[beanName.property=value]]></programlisting>
                <para>An example properties file might look like this:</para>
			    <programlisting><![CDATA[dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb]]></programlisting>
                <para>This example file would be usable against a container definition
                which contains a bean in it called <emphasis>dataSource</emphasis>,
                which has <emphasis>driver</emphasis> and <emphasis>url</emphasis>
                properties.</para>
                <para>Note that compound property names are also supported, as long as
                every component of the path except the final property being overridden is
                already non-null (presumably initialized by the constructors). In this
                example...</para>
                <programlisting><![CDATA[foo.fred.bob.sammy=123]]></programlisting>
                <para>... the <literal>sammy</literal> property of the <literal>bob</literal> property
                of the <literal>fred</literal> property of the <literal>foo</literal>
                bean is being set to the scalar value <literal>123</literal>.</para>
            </section>
        </section>
        <section id="beans-factory-extension-factorybean">
            <title>Customizing instantiation logic using <literal>FactoryBeans</literal></title>
            <para>The <interfacename>org.springframework.beans.factory.FactoryBean</interfacename>
            interface is to be implemented by objects that <emphasis>are themselves
            factories</emphasis>.</para>
            <para>The <interfacename>FactoryBean</interfacename> interface is a point of pluggability
            into the Spring IoC containers instantiation logic. If you have some complex
            initialization code that is better expressed in Java as opposed to a (potentially)
            verbose amount of XML, you can create your own <interfacename>FactoryBean</interfacename>,
            write the complex initialization inside that class, and then plug your custom
            <interfacename>FactoryBean</interfacename> into the container.</para>
            <para>The <interfacename>FactoryBean</interfacename> interface provides three methods:</para>
            <itemizedlist>
                <listitem>
                    <para><methodname>Object getObject()</methodname>: has to return an
                    instance of the object this factory creates. The instance can
                    possibly be shared (depending on whether this factory returns
                    singletons or prototypes).</para>
                </listitem>
                <listitem>
                    <para><methodname>boolean isSingleton()</methodname>: has to return
                    <literal>true</literal> if this <interfacename>FactoryBean</interfacename>
                    returns singletons, <literal>false</literal> otherwise</para>
                </listitem>
                <listitem>
                    <para><methodname>Class getObjectType()</methodname>: has to return
                    either the object type returned by the
                    <methodname>getObject()</methodname> method or <literal>null</literal>
                    if the type isn't known in advance</para>
                </listitem>
            </itemizedlist>
            <para>The <interfacename>FactoryBean</interfacename> concept and interface
            is used in a number of places within the Spring Framework; at the time of writing
            there are over 50 implementations of the <interfacename>FactoryBean</interfacename>
            interface that ship with Spring itself.</para>
            <para>Finally, there is sometimes a need to ask a container for an actual
            <interfacename>FactoryBean</interfacename> instance itself, not the bean it produces.
            This may be achieved by prepending the bean id with <literal>'&amp;'</literal>
            (sans quotes) when calling the <methodname>getBean</methodname> method of
            the <interfacename>BeanFactory</interfacename> (including
            <interfacename>ApplicationContext</interfacename>). So for a given
            <interfacename>FactoryBean</interfacename> with an id of <literal>myBean</literal>,
            invoking <literal>getBean("myBean")</literal> on the container will return the
            product of the <interfacename>FactoryBean</interfacename>, but invoking
            <literal>getBean("&amp;myBean")</literal> will return the
            <interfacename>FactoryBean</interfacename> instance itself.</para>
        </section>
    </section>
    <section id="context-introduction">
        <title>The <interfacename>ApplicationContext</interfacename></title>
        <para>While the <literal>beans</literal> package provides basic
        functionality for managing and manipulating beans, often in a programmatic
        way, the <literal>context</literal> package adds
        <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html">ApplicationContext</ulink></literal>,
        which enhances <interfacename>BeanFactory</interfacename> functionality in a more
        <emphasis>framework-oriented style</emphasis>. Many users will use
        <interfacename>ApplicationContext</interfacename> in a completely declarative fashion,
        not even having to create it manually, but instead relying on support classes such as
        <classname>ContextLoader</classname> to automatically start an <interfacename>ApplicationContext</interfacename> as part of the
        normal startup process of a J2EE web-app. Of course, it is still possible
        to programmatically create an ApplicationContext.</para>
        <para>The basis for the context package is the
        <interfacename>ApplicationContext</interfacename> interface, located in the
        <literal>org.springframework.context</literal> package. Deriving from the
        <interfacename>BeanFactory</interfacename> interface, it provides all the functionality of
        <interfacename>BeanFactory</interfacename>. To allow working in a more framework-oriented
        fashion, using layering and hierarchical contexts, the context package also provides the
        following functionality:</para>
        <itemizedlist>
                <listitem>
                    <para><interfacename>MessageSource</interfacename>, providing access to
                    messages in, i18n-style</para>
                </listitem>
                <listitem>
                    <para><emphasis>Access to resources</emphasis>, such as URLs and files</para>
                </listitem>
                <listitem>
                    <para><emphasis>Event propagation</emphasis> to beans implementing
                    the <interfacename>ApplicationListener</interfacename> interface</para>
                </listitem>
                <listitem>
                    <para><emphasis>Loading of multiple (hierarchical)
                    contexts</emphasis>, allowing each to be focused on one particular
                    layer, for example the web layer of an application</para>
                </listitem>
            </itemizedlist>
        <para>As the <interfacename>ApplicationContext</interfacename> includes all functionality of the
        <interfacename>BeanFactory</interfacename>, it is generally recommended that it be used over the
        <interfacename>BeanFactory</interfacename>, except for a few limited situations such as perhaps in an
        <classname>Applet</classname>, where memory consumption might be critical, and a few extra
        kilobytes might make a difference. The following sections described
        functionality which <interfacename>ApplicationContext</interfacename> adds to basic <interfacename>BeanFactory</interfacename>
        capabilities.</para>
        <section id="context-functionality-messagesource">
            <title>Internationalization using <literal>MessageSources</literal></title>
            <para>The <interfacename>ApplicationContext</interfacename> interface extends an interface called
            <interfacename>MessageSource</interfacename>, and therefore provides messaging (i18n
            or internationalization) functionality. Together with the
            <classname>NestingMessageSource</classname>, capable of resolving
            hierarchical messages, these are the basic interfaces Spring provides to
            do message resolution. Let's quickly review the methods defined there:</para>
            <itemizedlist>
                    <listitem>
                        <para><literal>String getMessage (String code, Object[] args,
                        String default, Locale loc)</literal>: the basic method used to
                        retrieve a message from the <interfacename>MessageSource</interfacename>. When no message is
                        found for the specified locale, the default message is used. Any
                        arguments passed in are used as replacement values, using the
                        <literal>MessageFormat</literal> functionality provided by the
                        standard library.</para>
                    </listitem>
                    <listitem>
                        <para><literal>String getMessage (String code, Object[] args,
                        Locale loc)</literal>: essentially the same as the previous
                        method, but with one difference: no default message can be
                        specified; if the message cannot be found, a
                        <classname>NoSuchMessageException</classname> is thrown.</para>
                    </listitem>
                    <listitem>
                        <para><literal>String getMessage(MessageSourceResolvable
						resolvable, Locale locale)</literal>: all properties used in the
						methods above are also wrapped in a class named
						<interfacename>MessageSourceResolvable</interfacename>, which you can use via
						this method.</para>
                    </listitem>
                </itemizedlist>
            <para>
				When an <interfacename>ApplicationContext</interfacename> gets loaded, it automatically searches
				for a <interfacename>MessageSource</interfacename> bean defined in the context. The bean has to have
				the name <literal>messageSource</literal>. If such a bean is found, all
				calls to the methods described above will be delegated to the message
				source that was found. If no message source was found, the
				<interfacename>ApplicationContext</interfacename> attempts to see if it has a parent containing a bean
				with the same name. If so, it uses that bean as the <interfacename>MessageSource</interfacename>. If it
				can't find any source for messages, an empty
				<classname>StaticMessageSource</classname> will be instantiated in order to
				be able to accept calls to the methods defined above.
			</para>
            <para>
				Spring currently provides two <interfacename>MessageSource</interfacename>
				implementations. These are the
				<classname>ResourceBundleMessageSource</classname> and the
				<classname>StaticMessageSource</classname>. Both implement
				<classname>NestingMessageSource</classname> in order to do nested messaging.
				The <classname>StaticMessageSource</classname> is hardly ever used but provides programmatic
				ways to add messages to the source. The <classname>ResourceBundleMessageSource</classname> is
				more interesting and is the one we will provide an example for:
      </para>
      <programlisting><![CDATA[<beans>
  <bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource">
    <property name="basenames">
      <list>
        <value>format</value>
        <value>exceptions</value>
        <value>windows</value>
      </list>
    </property>
  </bean>
</beans>]]></programlisting>
            <para>This assumes you have three resource bundles defined on your
      classpath called <literal>format</literal>,
      <literal>exceptions</literal> and <literal>windows</literal>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. For the purposes of the example,
      lets assume the contents of two of the above resource bundle files are...</para>
            <programlisting><lineannotation># in 'format.properties'</lineannotation><![CDATA[
message=Alligators rock!]]></programlisting>
            <programlisting><![CDATA[# in 'exceptions.properties'
argument.required=The '{0}' argument is required.]]></programlisting>
            <para>Some (admittedly trivial) driver code to exercise the
        <classname>MessageSource</classname> functionality can be found below. Remember
        that all <classname>ApplicationContext</classname> implementations are also
        <classname>MessageSource</classname> implementations and so can be cast to the
        <classname>MessageSource</classname> interface.</para>
            <programlisting><![CDATA[public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", null);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the above program will be...</para>
            <programlisting><![CDATA[Alligators rock!]]></programlisting>
            <para>So to summarize, the <classname>MessageSource</classname> is defined in a file
        called <literal>'beans.xml'</literal> (this file exists at the root of your classpath).
        The <literal>'messageSource'</literal> bean definition refers to a number
        of resource bundles via it's <literal>basenames</literal> property; the three files
        that are passed in the list to the <literal>basenames</literal> property exist as files
        at the root of your classpath (and are called
        <literal>format.properties</literal>, <literal>exceptions.properties</literal>,
        and <literal>windows.properties</literal> respectively).</para>
            <para>Lets look at another example, and this time we will look at passing arguments
        to the message lookup; these arguments will be converted into strings and inserted
        into placeholders in the lookup message. This is perhaps best explained with an
        example:</para>
            <programlisting><![CDATA[public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", null);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the running of the above program will be...</para>
            <programlisting><![CDATA[The 'userDao' argument is required.]]></programlisting>
            <para>With regard to internationalization (i18n), Spring's various
        <classname>MessageResource</classname> implementations follow the same locale resolution
        and fallback rules as the standard JDK ResourceBundle. In short, and continuing with
        the example <literal>'messageSource'</literal> defined previously, if you want to resolve
        messages against the British (en-GB) locale, one would create files called
        <literal>format_en_GB.properties</literal>, <literal>exceptions_en_GB.properties</literal>,
        and <literal>windows_en_GB.properties</literal> respectively.</para>
            <para>Locale resolution is typically going to be managed by the surrounding environment
        of the application. For the purpose of this example though, we'll just manually
        specify the locale that we want to resolve our (British) messages against.</para>
            <programlisting><![CDATA[# in 'exceptions_en_GB.properties'
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.]]></programlisting>
            <programlisting><![CDATA[public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}]]></programlisting>
            <para>The resulting output from the running of the above program will be...</para>
            <programlisting><![CDATA[Ebagum lad, the 'userDao' argument is required, I say, required.]]></programlisting>
            <para>The <classname>MessageSourceAware</classname> interface can also be used to acquire
            a reference to any <classname>MessageSource</classname> that has been defined. Any bean
            that is defined in an <classname>ApplicationContext</classname> that implements the
            <classname>MessageSourceAware</classname> interface will be injected with the
            application context's <classname>MessageSource</classname> when it (the bean) is being
            created and configured.</para>
        </section>
        <section id="context-functionality-events">
            <title>Events</title>
            <para>Event handling in the <interfacename>ApplicationContext</interfacename> is provided
			through the <classname>ApplicationEvent</classname> class and
			<interfacename>ApplicationListener</interfacename> interface. If a bean which
			implements the <interfacename>ApplicationListener</interfacename> interface is
			deployed into the context, every time an <classname>ApplicationEvent</classname>
			gets published to the <interfacename>ApplicationContext</interfacename>, that
			bean will be notified. Essentially, this is the standard <emphasis>Observer</emphasis>
			design pattern. Spring provides	three standard events:</para>
			<table frame="all">
                <title>Built-in Events</title>
                <tgroup cols="2">
                    <colspec colname="c1" colwidth="2*" />
                    <colspec colname="c2" colwidth="5*" />
                    <thead>
                        <row>
                            <entry>Event</entry>
                            <entry>Explanation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <classname>ContextRefreshedEvent</classname>
                            </entry>
                            <entry>
                                <para>Event published when the
                                <interfacename>ApplicationContext</interfacename> is
                                initialized or refreshed. Initialized here means that all
                                beans are loaded, singletons are pre-instantiated and the
                                <interfacename>ApplicationContext</interfacename> is ready
                                for use</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <classname>ContextClosedEvent</classname>
                            </entry>
                            <entry>
                                <para>Event published when the <interfacename>ApplicationContext</interfacename> is closed,
                                using the <methodname>close()</methodname> method on the
                                <interfacename>ApplicationContext</interfacename>. Closed here means
                                that singleton beans are destroyed</para>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <classname>RequestHandledEvent</classname>
                            </entry>
                            <entry>
                                <para>A web-specific event telling all beans that a HTTP
                                request has been serviced (i.e. this will be published
                                <emphasis>after</emphasis> the request has been finished).
                                Note that this event is only applicable for web applications
                                using Spring's <classname>DispatcherServlet</classname></para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>Implementing custom events can be done as well. Simply call the
			<methodname>publishEvent()</methodname> method on the <interfacename>ApplicationContext</interfacename>,
			specifying a parameter which is an instance of your custom event class
			implementing <classname>ApplicationEvent</classname>. Event listeners receive events
			synchronously. This means the <methodname>publishEvent()</methodname> method blocks until all
			listeners have finished processing the event (it is possible to supply
			an alternate event publishing strategy via a
			<interfacename>ApplicationEventMulticaster</interfacename> implementation).
			Furthermore, when a listener receives an event it operates inside the transaction context of
			the publisher, if a transaction context is available.</para>
            <para>Let's look at an example. First, the <interfacename>ApplicationContext</interfacename>:</para>
			<programlisting><![CDATA[<bean id="emailer" class="example.EmailBean">
  <property name="blackList">
    <list>
      <value>black@list.org</value>
      <value>white@list.org</value>
      <value>john@doe.org</value>
    </list>
  </property>
</bean>

<bean id="blackListListener" class="example.BlackListNotifier">
  <property name="notificationAddress" value="spam@list.org"/>
</bean>]]></programlisting>
			<para>Now, let's look at the actual classes:</para>
			<programlisting><![CDATA[public class EmailBean implements ApplicationContextAware {

    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        ]]><lineannotation>// send email...</lineannotation><![CDATA[
    }
}]]></programlisting>

<programlisting><![CDATA[public class BlackListNotifier implement ApplicationListener {

    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            ]]><lineannotation>// notify appropriate person...</lineannotation><![CDATA[
        }
    }
}]]></programlisting>
			<para>Of course, this particular example could probably be
			implemented in better ways (perhaps by using AOP features), but it
			should be sufficient to illustrate the basic event mechanism.</para>
        </section>
        <section id="context-functionality-resources">
            <title>Convenient access to low-level resources</title>
            <para>For optimal usage and understanding of application contexts, users
			should generally familiarize themselves with Spring's
			<interfacename>Resource</interfacename> abstraction, as described
			in the chapter entitled <xref linkend="resources" />.</para>
            <para>
				An application context is a <interfacename>ResourceLoader</interfacename>,
				able to be used to load <interfacename>Resource</interfacename>s. A
				<interfacename>Resource</interfacename> is essentially a
				<literal>java.net.URL</literal> on steroids (in fact, it just wraps and
				uses a URL where appropriate), which can be used to obtain low-level
				resources from almost any location in a transparent fashion, including
				from the classpath, a filesystem location, anywhere describable with a
				standard URL, and some other variations. If the resource location string
				is a simple path without any special prefixes, where those resources
				come from is specific and appropriate to the actual application context
				type.
			</para>
            <para>A bean deployed into the application context may implement the
			special marker interface, <interfacename>ResourceLoaderAware</interfacename>, to be
			automatically called back at initialization time with the application
			context itself passed in as the <interfacename>ResourceLoader</interfacename>.</para>
            <para>
				A bean may also expose properties of type
				<interfacename>Resource</interfacename>, to be used to access static resources, and
				expect that they will be injected into it like any other properties. The
				person deploying the bean may specify those <interfacename>Resource</interfacename>
				properties as simple String paths, and rely on a special JavaBean
				<interfacename>PropertyEditor</interfacename> that is automatically registerd by the context, to
				convert those text strings to actual <interfacename>Resource</interfacename>
				objects.
			</para>
            <para>The location path or paths supplied to an <interfacename>ApplicationContext</interfacename>
			constructor are actually resource strings, and in simple form are
			treated appropriately to the specific context implementation (i.e.
			<classname>ClassPathXmlApplicationContext</classname> treats a simple location path as a
			classpath location), but may also be used with special prefixes to force
			loading of definitions from the classpath or a URL, regardless of the
			actual context type.</para>
        </section>
        <section id="context-create">
            <title>Convenient <interfacename>ApplicationContext</interfacename> instantiation for web applications</title>
            <para>As opposed to the <interfacename>BeanFactory</interfacename>, which will
			often be created programmatically, <interfacename>ApplicationContext</interfacename>
			instances can be created declaratively using for example a
			<interfacename>ContextLoader</interfacename>. Of course you can also create
			<interfacename>ApplicationContext</interfacename> instances programmatically
			using one of the <interfacename>ApplicationContext</interfacename> implementations.
			First, let's examine the <interfacename>ContextLoader</interfacename> interface
			and its implementations.</para>
            <para>The <interfacename>ContextLoader</interfacename> interface has two implementations: the
			<classname>ContextLoaderListener</classname> and the
			<classname>ContextLoaderServlet</classname>. They both have the same
			functionality but differ in that the listener cannot be used in Servlet
			2.2 compatible containers. Since the Servlet 2.4 specification, listeners
			are required to initialize after startup of a web application. A lot of
			2.3 compatible containers already implement this feature. It is up to you
			as to which one you use, but all things being equal you should probably
			prefer <classname>ContextLoaderListener</classname>; for more information on
			compatibility, have a look at the Javadoc for the
			<classname>ContextLoaderServlet</classname>.</para>
            <para>You can register an <interfacename>ApplicationContext</interfacename> using the
			<classname>ContextLoaderListener</classname> as follows:</para>
		    <programlisting><![CDATA[<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
  <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>

]]><lineannotation>&lt;!-- or use the <classname>ContextLoaderServlet</classname> instead of the above listener</lineannotation><emphasis><![CDATA[
<servlet>
  <servlet-name>context</servlet-name>
  <servlet-class>org.springframework.web.context.ContextLoaderServlet</servlet-class>
  <load-on-startup>1</load-on-startup>
</servlet>
--]]></emphasis>&gt;</programlisting>
		    <para>The listener inspects the
			<literal>contextConfigLocation</literal> parameter. If it doesn't exist,
			it'll use <literal>/WEB-INF/applicationContext.xml</literal> as a default.
			When it <emphasis>does</emphasis> exist, it'll separate the String using
			predefined delimiters (comma, semi-colon and space) and use the values as
			locations where application contexts will be searched for. The
			<classname>ContextLoaderServlet</classname> can - as said - be used
			instead of the <classname>ContextLoaderListener</classname>. The servlet
			will use the <literal>'contextConfigLocation'</literal> parameter just
			as the listener does.</para>
        </section>
    </section>
    <section>
        <title>Glue code and the evil singleton</title>
        <para>The majority of the code inside an application is best written in a
		DI style, where that code is served out of a Spring IoC container, has its own
		dependencies supplied by the container when it is created, and is
		completely unaware of the container. However, for the small glue layers of
		code that are sometimes needed to tie other code together, there is
		sometimes a need for singleton (or quasi-singleton) style access to a
		Spring IoC container. For example,
		third party code may try to construct new objects directly (<literal>Class.forName()</literal>
		style), without the ability to force it to get these objects out of a
		Spring IoC container. If the object constructed by the
		third party code is just a small stub or proxy, which then uses a singleton style access to a
		Spring IoC container to get a real object to delegate to, then inversion of control has
		still been achieved for the majority of the code (the object coming out of the
		container); thus most code is still	unaware of the container or how it is accessed, and
		remains uncoupled from other code, with all ensuing benefits. EJBs may also use this stub/proxy
		approach to delegate to a plain Java implementation object, coming out of
		a Spring IoC container. While the Spring IoC container itself ideally does not have to be a
		singleton, it may be unrealistic in terms of memory usage or initialization times (when
		using beans in the Spring IoC container such as a Hibernate
		<interfacename>SessionFactory</interfacename>) for each bean to use its own, non-singleton
		Spring IoC container.</para>
        <para>As another example, in a complex J2EE apps with multiple layers
        (i.e. various JAR files, EJBs, and WAR files packaged as an EAR),
        with each layer having its own Spring IoC container definition
        (effectively forming a hierarchy), the preferred approach when
        there is only one web-app (WAR) in the top hierarchy is to simply
        create one composite Spring IoC container from the multiple XML definition
        files from each layer. All of the various Spring IoC container implementations
        may be constructed from multiple definition files in this fashion.
        However, if there are multiple sibling web-applications at the root
        of the hierarchy, it is problematic to create a
        Spring IoC container for each web-application
        which consists of mostly identical bean definitions from lower layers,
        as there may be issues due to increased memory usage, issues with
        creating multiple copies of beans which take a long time to initialize
        (e.g. a Hibernate <interfacename>SessionFactory</interfacename>), and
        possible issues due to side-effects. As an alternative, classes such as
        <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">ContextSingletonBeanFactoryLocator</ulink></literal>
        or
        <literal><ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink></literal>
        may be used to demand load multiple hierarchical (i.e. one is a parent of
        another) Spring IoC container instances in an effectively singleton fashion,
        which may then be used as the parents of the web-application Spring IoC
        container instances. The result is that bean definitions for lower layers are
        loaded only as needed, and loaded only once.</para>
        <section>
            <title>Using the Singleton-helper classes</title>
            <para>One can see a detailed example of using
            <ulink url="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html">SingletonBeanFactoryLocator</ulink>
            and
            <ulink url="http://www.springframework.org/docs/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html">ContextSingletonBeanFactoryLocator</ulink>
            by viewing their respective Javadocs.
            </para>
            <para>As mentioned in the <link linkend="ejb">chapter on EJBs</link>, the
            Spring convenience base classes for EJBs normally use a non-singleton
            <interfacename>BeanFactoryLocator</interfacename> implementation, which is
            easily replaced by the use of <classname>SingletonBeanFactoryLocator</classname>
            and <classname>ContextSingletonBeanFactoryLocator</classname> if there is
            a need.</para>
        </section>
    </section>
</chapter>
