<?xml version="1.0" encoding="UTF-8" ?>
<chapter id="aspectj">
	<title>Spring and AspectJ</title>
	<section>
		<title>Overview</title>
		<para>
			Spring's proxy-based AOP framework is well suited for handling many
			generic middleware and application-specific problems. With its ability to
			use the AspectJ pointcut expression language (introduced in 2.0), Spring
			AOP has gained access to some of the strengths of AspectJ, within the
			proxy-based model.
		</para>
		<para>
			However, there are times when a proxy-based AOP solution is not
			sufficient: for example, if we need to add additional fields to a class,
			apply advice to joinpoints other than method execution, or advise
			fine-grained objects that aren't created by the Spring IoC
			container.
		</para>
		<para>
			The Spring team recommend the use of AspectJ in such cases. AspectJ is the
			de-facto standard for full-featured AOP. Accordingly, since version 1.1,
			Spring has provided a powerful integration with AspectJ, and from release
			2.0 onwards further areas of integration are being added.
		</para>
		<para>
			Both Spring and AspectJ gain from this combination. Spring gains
			through adding the ability (via AspectJ) to dependency inject objects not
			instantiated by the Spring container; AspectJ users gain for their aspects
			similar benefits to those that Spring brings to configuring
			classes.
		</para>
		<para>
			<remark>To use the features described in this chapter you will need
			to use the AJC compiler provided by AspectJ, or use AspectJ load-time
			weaving. For these features, weaving must be performed by AspectJ rather
			than Spring AOP. You can use either the traditional AspectJ syntax (with
			aspect being a keyword) or you can use the annotation-style syntax
			introduced in AspectJ 5.</remark>
		</para>
	</section>
	<section>
		<title>Using AspectJ to dependency inject objects using Spring</title>
		<para>
			Spring 2.0 introduces an AspectJ aspect that can be used to
			dependency inject objects not created by the Spring container. This can
			include objects instantiated by an O/R mapping framework, and objects
			simply constructed using the <literal>new</literal> operator. This is a
			particularly useful mechanism to avoid the
			<ulink url="http://www.martinfowler.com/bliki/AnemicDomainModel.html">'anemic domain model'</ulink>
			criticized by Martin Fowler and other OO experts.
			</para>
		<para>
			This mechanism is achieved through a dependency injected AspectJ
			aspect. This mechanism is described in the next section.
		</para>
		<para>
			TODO: examples
		</para>
	</section>
	<section>
		<title>Configuring AspectJ aspects using Spring IoC</title>
		<para>
			The Spring / AspectJ integration allows Spring to configure AspectJ
			aspects using Dependency Injection. This brings similar benefits to
			aspects as to objects. For example:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					There is no need for aspects to use ad hoc configuration
					mechanisms; they can be configured in the same, consistent, approach
					used for the entire application.
				</para>
			</listitem>
			<listitem>
				<para>
					Aspects can depend on application objects. For example, a
					security aspect can depend on a security manager, as we'll see in an
					example shortly.
				</para>
			</listitem>
			<listitem>
				<para>
					It's possible to obtain a reference to an aspect through the
					relevant Spring context. This can allow for dynamic reconfiguration of
					the aspect.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			AspectJ aspects can expose JavaBean properties for Setter Injection,
			and even implement Spring lifecycle interfaces such as
			<interfacename>BeanFactoryAware</interfacename>.
		</para>
		<remark>
			<para>
				Note that AspectJ aspects cannot use Constructor Injection or
				Method Injection. This limitation is due to the fact that aspects do not
				have constructors that can be invoked like the constructors of regular classes.
			</para>
		</remark>
		<section>
			<title>"Singleton" aspects</title>
			<para>
				In most cases, AspectJ aspects are singletons, with one instance
				per class loader. This single instance is responsible for advising
				multiple object instances.
			</para>
			<para>
				A Spring IoC container cannot instantiate an aspect, as aspects
				don't have callable constructors. But it can obtain a reference to an
				aspect using the <literal>static</literal> <literal>aspectOf()</literal>
				method that AspectJ defines for all aspects, and it can inject
				dependencies into that aspect.
			</para>
			<section>
				<title>Example</title>
				<para>
					Consider a security aspect, which depends on a security manager.
					This aspects applies to all changes in the value of the
					<literal>balance</literal> instance variable in the
					<literal>Account</literal> class. (We couldn't do this in the same way
					using Spring AOP.)
				</para>
				<para>
					The AspectJ code for the aspect (one of the Spring/AspectJ
					samples), is shown below. Note that the dependency on the
					<interfacename>SecurityManager</interfacename> interface is
					expressed in a JavaBean property:
				</para>
				<programlisting><![CDATA[public aspect BalanceChangeSecurityAspect {

   private SecurityManager securityManager;

   public void setSecurityManager(SecurityManager securityManager) {
      this.securityManager = securityManager;
   }

   private pointcut balanceChanged() : 
      set(int Account.balance);

   before() : balanceChanged() {
      this.securityManager.checkAuthorizedToModify();
   }
}]]></programlisting>
				<para>
					We configure this aspect in the same way as an ordinary class.
					Note that the way in which we set the property reference is identical.
					Note that we must use the <literal>factory-method</literal> attribute
					to specify that we want the aspect "created" using the
					<literal>aspectOf()</literal> <literal>static</literal> method.
					In fact, this is <emphasis>locating</emphasis>, rather than,
					<literal>creating</literal>, the aspect, but the Spring container
					doesn't care:
				</para>
				<programlisting><![CDATA[<bean id="securityAspect" 
   class="org.springframework.samples.aspectj.bank.BalanceChangeSecurityAspect" 
   factory-method="aspectOf"
>
   <property name="securityManager" ref="securityManager"/>
</bean>]]></programlisting>
				<para>
					We don't need to do anything in Spring configuration to target
					this aspect. It contains the pointcut information in AspectJ code that
					controls where it applies. Thus it can apply even to objects not
					managed by the Spring IoC container.
				</para>
			</section>
			<section>
				<title>Ordering issues</title>
				<para>[TODO]</para>
			</section>
		</section>
		<section>
			<title>Non-singleton aspects</title>
			<para>[TODO : ** Complete material on pertarget etc.]</para>
		</section>
		<section>
			<title>Gotchas</title>
			<para>[TODO]</para>
		</section>
	</section>
	<section>
		<title>Using the AspectJ pointcut language with Spring AOP</title>
		<para>
			Spring AOP does not define a true pointcut expression language:
			merely convenient pointcuts that work with regular expressions.
		</para>
		<para>
			AspectJ provides a powerful, well thought out pointcut expression
			language.
		</para>
		<para>
			As of the AspectJ 5 release, the AspectJ weaver has been split from the
			<literal>ajc</literal> compiler, making it available to back a generic Spring
			AOP pointcut implementation. This implementation -
			<classname>AspectJExpressionPointcut</classname> - is added to Spring in Spring
			2.0. This enables Spring AOP to work with AspectJ pointcut
			expressions.
		</para>
		<para>
			Weaving is still proxy-based, using Spring AOP. This does impose
			some limitations: notably, only method execution joinpoints are supported.
			(It is impossible for a proxy-based framework to modify the callers of
			methods.) However, a valuable subset of AspectJ pointcut expressions are
			supported, including advanced features such as argument binding, pointcut
			composition and references to named pointcuts.
		</para>
		<para>
			<remark>The annotation processing functionality described in this
			chapter is only available using AspectJ 5. Processing of the
			<literal>@AspectJ</literal> annotation-style syntax is only available
			using Java 5 as well as AspectJ 5. Externalization of pointcut expression
			strings into XML does not require Java 5.</remark>
		</para>
	</section>
	<section>
		<title>AspectJExpressionPointcut</title>
		<para>Demonstrate how it works</para>
		<para>Show with ProxyFactory programmatic creation</para>
		<para>Java 5</para>
	</section>
	<section>
		<title>Using AspectJ pointcut expressions in Spring XML</title>
		<para>[TODO]</para>
	</section>
	<section id="aspectj-ataspectj">
		<title>Using the AspectJ 5 <literal>@AspectJ</literal> annotation-style syntax in Spring AOP</title>
		<section>
			<title>Overview</title>
			<para>
				AspectJ 5 introduces a new annotation-style syntax, in addition to
				the traditional AspectJ syntax. With the annotation style syntax,
				aspects can be compiled by Javac.
			</para>
			<para>
				This syntax places pointcut expression strings in annotations.
			</para>
			<para>
				<remark>Spring also supports AspectJ semantics, with pointcut
				expressions in Spring XML configuration files. This does not require
				Java 5. It is discussed in the next section. All coverage of actual
				advice, including argument binding, is equally relevant to this style of
				use: the semantics, are identical - only the location of the pointcut
				expression strings differs.</remark>
			</para>
		</section>
		<section>
			<title>Simple advice types</title>
			<para>
				In Spring AOP, an advice is an implementation of an interface such
				as MethodInterceptor or MethodBeforeAdvice. A pointcut is an
				implementation of a Java interface that identifies whether given
				joinpoints match. An advice and pointcut - together making up an
				aspect - are held together in an Advisor.
			</para>
			<para>
				In <literal>@AspectJ</literal>, an aspect is a class annotated with an @Aspect
				annotation. It can contain advice methods that are annotated with
				AspectJ annotations such as <literal>@Before</literal> and <literal>@Around</literal>. Pointcuts are indicated
				by the value of the expression string (the default value attribute) held
				in these annotations. Classes annotated with @Aspect can also contain
				named pointcuts (methods annotated with the @Pointcut annotation), and
				introductions.
			</para>
		</section>
		<section>
			<title>Argument binding</title>
			<para>Major advantage</para>
			<para>Description</para>
			<para>Argument naming challenges: strategies</para>
			<para>Choices, fallbacks</para>
		</section>
		<section>
			<title>Special types</title>
			<para>
				AspectJ supports the binding of well-known types, such as the
				current JoinPoint, and returned value and thrown throwable (if
				applicable to the advice method).
			</para>
			<para>TODO full list</para>
			<para>Two special cases are the this and target values.</para>
			<para>
				This, when bound or retrieved from JoinPoint.getThis(), returns
				the current Spring AOP proxy. This allows invocation through the advice
				chain, or casting to an introduced interface.
			</para>
			<para>
				Target, when bound or retrieved, returns the current target. This
				is a plain POJO, not advised.
			</para>
		</section>
		<section>
			<title>Named pointcuts</title>
			<para>
				It is possible to reference named pointcuts in AspectJ aspects
				available on the class path, even if they were authored with traditional
				AspectJ syntax. This is accomplished using the FQN of the relevant
				pointcut. For example, here is an AspectJ aspect:
			</para>
			<programlisting><![CDATA[package org.springframework.aop.aspectj.annotation.annotation.support;

public aspect CommonPointcuts {

  public pointcut anyGetter() : execution(!void get*(..));
  
  public pointcut anyIntArg(int x) : args(x);

}]]></programlisting>
			<para>
				This aspect can be referenced as follows in <literal>@AspectJ</literal> syntax:
			</para>
			<programlisting><![CDATA[@Around(value="org.springframework.aop.aspectj.annotation.annotation.support.CommonPointcuts.anyIntArg(x)", argNames="x")
public void doubleArg(ProceedingJoinPoint pjp, int x) throws Throwable {
   pjp.proceed(new Object[]{x*2});
}]]></programlisting>
		</section>
		<section>
			<title>Aspect instantiation models</title>
			<para>
				Spring AOP "natively" supports two aspect instantiation models:
			</para>
			<para>Singleton</para>
			<para>Per-instance</para>
			<para>
				This correspond to the advisor or/and advice being a singleton or
				non-singleton in Spring IoC configuration.
			</para>
			<para>
				AspectJ supports a different, richer, set of instantiation models.
				However, in AspectJ as in Spring, the singleton instantiation (which is
				the default) is by far the most useful.
			</para>
			<para>The full range of AspectJ instantiation models is:</para>
			<para>singleton</para>
			<para>perthis</para>
			<para>pertarget</para>
			<para>pertypewithin</para>
			<para>percflow</para>
			<para>percflowbelow</para>
			<para>
				Spring can support the following aspect AspectJ instantiation
				models, and will automatically respect such annotations:
			</para>
			<para>singleton</para>
			<para>perthis</para>
			<para>pertarget</para>
			<para>pertypewithin</para>
			<para>
				If you use a binding type that is not supported, Spring will
				throw an exception. Thus you cannot get unexpected semantics.
			</para>
			<para>TODO example of binding models</para>
		</section>
		<section>
			<title>Introductions</title>
			<para>
				Spring supports AspectJ-style introductions. These are
				significantly more elegant than the "native" Spring AOP equivalent,
				using <classname>DelegatingIntroductionInterceptor</classname>.
			</para>
			<para>
				For example, consider a simple interface expressing locking status:
			</para>
			<programlisting><![CDATA[public interface Lockable {

    void lock();

    void unlock();

    boolean locked();
}]]></programlisting>
			<para>
				Imagine that we wish to introduce this interface to make a number
				of objects <interfacename>Lockable</interfacename>. This means both
				making those objects implement the
				<interfacename>Lockable</interfacename> interface, and also changing
				the behaviour of their setter methods to throw an exception if they
				are locked.
			</para>
			<para>
				This is achieved using the following <literal>@AspectJ</literal>
				aspect. We assume an implementation of
				<interfacename>Lockable</interfacename> called
				<classname>DefaultLockable</classname>, although it is a
				common idiom for the aspect itself to declare an implementation in an
				inner class.
			</para>
			<programlisting><![CDATA[@Aspect
public class MakeLockable {

   @DeclareParents(value = "org.springframework..*",
      defaultImpl=DefaultLockable.class)
   public static Lockable mixin;
 
   @Before(value="execution(* set*(*)) &amp;&amp; this(mixin)", argNames="mixin")
   public void checkNotLocked(Lockable mixin) {
      if (mixin.locked()) {
         throw new IllegalStateException();
      }
   }
}]]></programlisting>
			<para>
				The field annotated with the <literal>DeclareParents</literal>
				element specifies an AspectJ type pattern to which the introduction
				will be apply. Note that this variable must be <literal>static</literal>.
				The defaultImpl attribute of the
				DeclareParents attribute is used to specify the class name to use to
				make the introduction.
			</para>
			<para>
				In this example, the before advice works in conjuction with the
				<interfacename>Lockable</interfacename> mixin to change the behaviour of setter methods to throw an
				exception if the object is locked. This is achieved through a pointcut
				expression identifying setters, and also binding "this" to an argument
				on the method advice, enabling the locking state to be tested.
			</para>
			<para>
				The argNames attribute is required on the before advice, to ensure
				correct argument binding (unless compiling with a debug flag).
			</para>
		</section>
		<section>
			<title>Mixing Spring AOP aspects and <literal>@AspectJ</literal> aspects</title>
			<para>
				There is no conflict between Spring AOP and <literal>@AspectJ</literal> aspects. All
				weaving is performed at runtime by Spring AOP, so as far as the core
				Spring AOP runtime is concerned, it is merely working with pointcuts and
				advices.
			</para>
		</section>
		<section>
			<title>Auto proxy creation and @AspectJ</title>
			<para>
				As you would expect, it is possible to use auto proxy creation
				with <literal>@AspectJ</literal> syntax. This is achieved using
				<classname>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</classname>.
				This is a subclass of <classname>DefaultAdvisorAutoProxyCreator</classname>,
				meaning that it will also apply any Spring AOP advisors found in the
				application context to which it applies.
			</para>
			<para>
				Usage is very simple. Just add the following definition to your
				application context:
			</para>
			<programlisting><![CDATA[<bean 
  class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator" />]]></programlisting>
			<para>
				No configuration is usually required. See the documentation on
				<classname>DefaultAutoProxyCreator</classname> and superclasses for the regular configuration
				that applies to auto proxy creators.
			</para>
			<para>
				The effect will be that any <literal>@AspectJ</literal> aspects will automatically be
				recognized and applied, in addition to Spring advisors. You can use
				<classname>AspectJAutoProxyCreator</classname> anywhere you would use
				<classname>DefaultAutoProxyCreator</classname>.
			</para>
			<para>
				<literal>@AspectJ</literal> aspects can be dependency injected, and will not
				themselves be subjected to auto proxying, to avoid circular
				dependencies.
			</para>
		</section>
	</section>
	<section id="aspectj-atconfigurable">
		<title>Dependency injection using AspectJ with @<interfacename>Configurable</interfacename></title>
		<para>
			[TODO]
		</para>
	</section>
	<section>
		<title>AspectJ advice with pointcut expressions in Spring XML</title>
		<para>
			In this style of use, the semantics are identical to <literal>@AspectJ</literal>.
			However, pointcut expression strings are expressed in Spring XMl, rather
			than source-level annotations. This is usable without Java 5. It also
			provides the ability to invoke arbitrary methods on POJOs, with no
			requirements on the classes or methods to know anything about Spring or
			AspectJ.
		</para>
		<para>Advice methods follow AspectJ conventions.</para>
		<para>Use looks as follows:</para>
		<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd">


   <aop:config>
    <aop:aspect id="beforeAdviceBindingTests" ref="testAspect">
      <aop:advice 
         kind="after"
         method="oneIntArg"
         pointcut="execution(* setAge(int)) and args(age)"
      />
      <aop:advice
         kind="after"
         method="oneObjectArg"
         pointcut="execution(* getAge()) and this(bean)"
      />
      <aop:advice
          kind="afterReturning"
          method="oneObjectArg"
          pointcut="execution(* getDoctor()) and target(bean)"
      />
     </aop:aspect>
   </aop:config>

   <bean id="testAspect" class="org.springframework.aop.aspectj.AdviceBindingTestAspect"/>

   <bean id="testBean" class="org.springframework.beans.TestBean"/>

</beans>]]></programlisting>
		<para>Notes:</para>
		<itemizedlist>
			<listitem>
				<para>
					Import of the Spring 2.0 AOP namespace in the beans element
				</para>
			</listitem>
			<listitem>
				<para>The use of one &lt;aop:config&gt; element to configure a set of
        aspects that will automatically be applied using autoproxying</para>
			</listitem>
			<listitem>
				<para>Use of one or more &lt;aop:aspect&gt; element to specify the
        advice methods in a particular bean. The bean is identified using the
        ref element. In the previous example, for example, we could also
        dependency inject the "testAspect" bean.</para>
			</listitem>
			<listitem>
				<para>The use of one or more &lt;aop:advice&gt; elements beneath each
        &lt;aop:aspect&gt; element to identify the various advices that make
        up an aspect. Note the specification of kind, indicating what kind of
        advice this is. The other required attributes are "pointcut" - an
        AspectJ 5 pointcut expression string - and "method". Method is the name
        of a method. Note that overloaded methods will still work, based on
        the argumnets bound in the pointcut expression.</para>
			</listitem>
			<listitem>
				<para>Argument binding is handled through the pointcut
        expression.</para>
			</listitem>
			<listitem>
				<para>As with <literal>@AspectJ</literal>, it is possible for the method to take unbound
        arguments of well-known types such as JoinPoint. However, there is no
        requirement for the method to have any dependence on AspectJ.</para>
			</listitem>
		</itemizedlist>
		<para>The valid advice kinds follow AspectJ rules, and are:</para>
		<itemizedlist>
			<listitem>
				<para>before</para>
			</listitem>
			<listitem>
				<para>after</para>
			</listitem>
			<listitem>
				<para>afterReturning</para>
			</listitem>
			<listitem>
				<para>afterThrowing</para>
			</listitem>
			<listitem>
				<para>around</para>
			</listitem>
		</itemizedlist>
		<para>
			Each of these advice kinds corresponds to an <literal>@AspectJ</literal> annotation,
			which would include a pointcut expression.
		</para>
		<para>
			The following is an example of a class that could be used with the
			above XML:
		</para>
		<programlisting><![CDATA[public class AdviceBindingTestAspect {

  public void oneIntArg(int age) {
     this.collaborator.oneIntArg(age);
  }

  public void needsJoinPointStaticPart(JoinPoint.StaticPart tjpsp) {
     this.collaborator.needsJoinPointStaticPart(tjpsp.getSignature().getName());
  }
}]]></programlisting>
		<para>
			The following shows an <literal>@AspectJ</literal> version, equivalent to the XML and
			Java code. The semantics are identical, and both can be used with Spring:
		</para>
		<programlisting><![CDATA[@Aspect
public class AdviceBindingTestAspect {

  @Before("execution(* setAge(int)) and args(age)")
  public void oneIntArg(int age) {
    this.collaborator.oneIntArg(age);
  }

  @After("execution(* getAge())")
  public void needsJoinPointStaticPart(JoinPoint.StaticPart tjpsp) {
    this.collaborator.needsJoinPointStaticPart(tjpsp.getSignature().getName());
  }
}]]></programlisting>
		<para>TODO show AspectJ style aspect also</para>
	</section>
	<section>
		<title>Other Spring aspects for AspectJ</title>
		<para>
			In a future release of Spring, we will package some Spring services,
			such as the declarative transaction management service, as AspectJ
			aspects. This will enable them to be used by AspectJ users without
			dependence on the Spring AOP framework--potentially, even without
			dependence on the Spring IoC container.
		</para>
		<para>
			This feature is probably of more interest to AspectJ users than
			Spring users.
		</para>
	</section>
	<section id="aspectj-resources">
		<title>Further Resources</title>
		<para>
            Find below links to further resources about AspectJ.
        </para>
		<itemizedlist>
			<listitem>
				<para>
					The AspectJ
					<ulink url="http://www.eclipse.org/aspectj/doc/released/progguide/index.html">Programmers Guide</ulink>,
					included in the AspectJ 5 distribution, is an excellent starting point.
				</para>
			</listitem>
			<listitem>
				<para>The <ulink url="http://www.eclipse.org/aspectj/">AspectJ</ulink> homepage</para>
			</listitem>
		</itemizedlist>
	</section>
</chapter>